<!-- 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D JS CAD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />
    <style>
        /* General body and font styling */
        :root {
            --brand-color: #4338ca;
            --brand-color-hover: #312e81;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #9ca3af;
            --gray-500: #6b7280;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --white: #fff;
            --red: #ef4444;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling */
            display: grid;
            grid-template-rows: 1fr auto;
            grid-template-columns: 1fr auto;
            grid-template-areas:
                "main sidebar"
                "footer sidebar";
            height: 100vh;
            background-color: var(--gray-100);
        }

        #canvas-container {
            grid-area: main;
            position: relative;
        }

        #rightSidebar {
            grid-area: sidebar;
            width: 192px; /* w-48 */
            background-color: var(--gray-200);
            padding: 1rem;
            border-left: 1px solid var(--gray-300);
        }

        #footerBar {
            grid-area: footer;
            height: 96px; /* h-24 */
            background-color: var(--gray-300);
            padding: 1rem;
            border-top: 1px solid var(--gray-400);
        }

        /* Active tool button styling */
        .active-tool {
            background-color: var(--brand-color) !important;
            color: var(--white) !important;
        }

        /* Full-screen canvas */
        #myCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            touch-action: none; /* Prevent default touch actions like scroll/zoom */
        }

        /* Floating top menu */
        #topBar {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(8px);
        }
        
        /* Dropdown container */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            border-radius: 0.5rem;
            padding: 0.5rem;
            margin-top: 0.5rem;
        }

        .dropdown-content button {
            width: 100%;
            margin-bottom: 0.25rem;
        }
        
        #ellipseTool span {
             display: inline-block;
             transform: scaleX(1.5);
        }

        /* Custom context menu styles for right-click actions */
        #customContextMenu {
            position: absolute;
            background-color: var(--white);
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            padding: 0.5rem;
            z-index: 1000;
            display: none;
        }

        .context-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--gray-800);
        }
        
        .context-menu-item:hover {
            background-color: var(--gray-100);
        }
        
        .context-menu-item.danger {
            color: var(--red);
        }
        .context-menu-item.danger:hover {
             background-color: #fee2e2;
        }

        /* Generic Modal Styling */
        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            background-color: var(--white);
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            display: none;
            flex-direction: column;
            width: 280px;
        }

        .modal-content input,
        .modal-content select {
            padding: 0.5rem;
            border: 1px solid var(--gray-300);
            border-radius: 0.375rem;
            width: 100%;
            margin-bottom: 1rem;
            font-size: 1rem;
            outline: none;
        }
        
        .modal-content label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--gray-700);
        }

        .button-group {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .modal-button {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 600;
            transition: background-color 200ms;
        }

        .modal-button.ok {
            background-color: var(--brand-color);
            color: var(--white);
            border: none;
        }

        .modal-button.ok:hover {
            background-color: var(--brand-color-hover);
        }

        .modal-button.cancel {
            background-color: var(--gray-100);
            color: var(--gray-700);
            border: 1px solid var(--gray-300);
        }

        .modal-button.cancel:hover {
            background-color: var(--gray-200);
        }
        
        /* Shape Inspector Panel */
        #shapeInspectorPanel {
            position: absolute; /* Will be managed by JS */
            top: 1rem;
            right: 1rem;
            width: 220px; /* More compact width */
            z-index: 2000;
            cursor: move;
            padding: 0; /* Remove default modal padding to have more control */
        }
        
        #inspectorHeader {
            padding: 0.5rem 0.75rem; /* Compact padding */
            font-size: 0.875rem; /* Smaller font */
            background-color: var(--gray-100);
            border-top-left-radius: 0.75rem;
            border-top-right-radius: 0.75rem;
            font-weight: 600;
            border-bottom: 1px solid var(--gray-300);
        }
        
        #shapeInspectorPanel .modal-content {
             padding: 0.75rem;
             display: flex;
             flex-direction: column;
             gap: 0.5rem;
        }

        /* MODIFICATIONS FOR COMPACT PANELS */
        .inspector-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #shapeInspectorPanel .modal-content label {
            margin-bottom: 0;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--gray-700);
        }
        #shapeInspectorPanel .modal-content input,
        #shapeInspectorPanel .modal-content select {
            width: 110px;
            padding: 0.25rem;
            font-size: 0.75rem;
            margin-bottom: 0;
        }
        #shapeInspectorPanel .modal-content input[type="color"] {
            padding: 0;
            height: 24px;
        }
        #shapeInspectorPanel .button-group {
            margin-top: 0.5rem;
            padding: 0 0.75rem 0.75rem; /* Add padding here instead of the main modal div */
        }
        #shapeInspectorPanel .modal-button {
            padding: 0.25rem 0.75rem;
            font-size: 0.75rem;
        }

        /* Edit Dimension Modal COMPACT STYLES */
        #editDimensionModal {
            width: 240px;
            padding: 1rem;
            cursor: move;
        }
        #editDimensionModal h3 {
            font-size: 1rem;
            font-weight: 700;
            margin-bottom: 0.75rem;
        }
        #editDimensionModal .modal-content label {
            font-size: 0.875rem;
        }
        #editDimensionModal .modal-content input {
            padding: 0.375rem;
            margin-bottom: 0.75rem;
            font-size: 0.875rem;
        }
        #editDimensionModal .button-group {
            margin-top: 0.5rem;
        }
        #editDimensionModal .modal-button {
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
        }
    </style>
</head>
<body>
    
    <!-- Floating Top menu with all tool and action icons -->
    <div id="topBar" class="flex items-center gap-1 p-2 rounded-lg shadow-md">
        <!-- Select/Move Tool -->
        <button id="selectTool" class="w-9 h-9 flex items-center justify-center text-lg rounded-md bg-indigo-500 text-white shadow-lg hover:bg-indigo-600 focus:outline-none transition-colors duration-200 active-tool" aria-label="Select Tool">
            <i class="fas fa-mouse-pointer"></i>
        </button>

        <!-- Drawing Tools Dropdown -->
        <div class="dropdown">
            <button id="drawToolsButton" class="w-9 h-9 flex items-center justify-center font-semibold text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Drawing Tools">
                <span id="activeDrawToolIcon">—</span>
            </button>
            <div id="drawToolsDropdown" class="dropdown-content">
                <button id="lineTool" data-tool="line" class="w-full h-9 flex items-center justify-center font-semibold text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Line Tool">
                    <span class="sr-only">Line Tool</span>—
                </button>
                <button id="rectangleTool" data-tool="rectangle" class="w-full h-9 flex items-center justify-center font-semibold text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Rectangle Tool">
                    <span class="sr-only">Rectangle Tool</span>&#9633;
                </button>
                <button id="circleTool" data-tool="circle" class="w-full h-9 flex items-center justify-center font-semibold text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Circle Tool">
                    <span class="sr-only">Circle Tool</span>○
                </button>
                <button id="arcTool" data-tool="arc" class="w-full h-9 flex items-center justify-center font-semibold text-2xl rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Arc Tool">
                    <span class="sr-only">Arc Tool</span>⌒
                </button>
                <button id="ellipseTool" data-tool="ellipse" class="w-full h-9 flex items-center justify-center font-semibold text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Ellipse Tool">
                    <span class="sr-only">Ellipse Tool</span><span>○</span>
                </button>
                <button id="splineTool" data-tool="spline" class="w-full h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Spline Tool">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                </button>
            </div>
        </div>
        
        <!-- Smart Dimension Tool -->
        <button id="dimensionTool" data-tool="dimension" class="w-9 h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Dimension Tool">
            <i class="fas fa-ruler-combined"></i>
        </button>
        
        <!-- Constraint Tools Dropdown -->
        <div class="dropdown">
            <button id="constraintToolsButton" class="w-9 h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Constraint Tools">
                 <span id="activeConstraintToolIcon"><i class="fas fa-link"></i></span>
            </button>
            <div id="constraintToolsDropdown" class="dropdown-content">
                <button id="coincidentConstraintTool" data-tool="coincidentConstraint" class="w-full h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Coincident Constraint Tool">
                    <i class="fas fa-link"></i>
                </button>
                 <button id="tangentConstraintTool" data-tool="tangentConstraint" class="w-full h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Tangent Constraint Tool">
                    <i class="fas fa-bullseye"></i>
                </button>
                <button id="fixConstraintTool" data-tool="fixConstraint" class="w-full h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Fix Constraint Tool">
                    <i class="fas fa-anchor"></i>
                </button>
                <button id="horizontalConstraintTool" data-tool="horizontalConstraint" class="w-full h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Horizontal Constraint Tool">
                     <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 12H5"></path></svg>
                </button>
                <button id="verticalConstraintTool" data-tool="verticalConstraint" class="w-full h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Vertical Constraint Tool">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19V5"></path></svg>
                </button>
                <button id="parallelConstraintTool" data-tool="parallelConstraint" class="w-full h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Parallel Constraint Tool">
                    <svg class="w-5 h-5 transform -rotate-12" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 12H5M19 7H5"></path></svg>
                </button>
                <button id="perpendicularConstraintTool" data-tool="perpendicularConstraint" class="w-full h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Perpendicular Constraint Tool">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18 6v12M6 18h12"></path></svg>
                </button>
                <button id="collinearConstraintTool" data-tool="collinearConstraint" class="w-full h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Collinear Constraint Tool">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 12h16m-11-2v4m6-4v4"></path></svg>
                </button>
            </div>
        </div>

        <!-- Modify Tools Dropdown -->
        <div class="dropdown">
            <button id="modifyToolsButton" class="w-9 h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Modify Tools">
                <span id="activeModifyToolIcon"><i class="fas fa-cut"></i></span>
            </button>
            <div id="modifyToolsDropdown" class="dropdown-content">
                <button id="trimTool" data-tool="trim" class="w-full h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Trim Tool">
                    <i class="fas fa-cut"></i>
                </button>
                <button id="offsetTool" data-tool="offset" class="w-full h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Offset Tool">
                    <i class="fas fa-expand-arrows-alt"></i>
                </button>
                <button id="filletTool" data-tool="fillet" class="w-full h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Fillet Tool">
                    <i class="fas fa-draw-polygon"></i> <!-- Placeholder icon -->
                </button>
                <button id="chamferTool" data-tool="chamfer" class="w-full h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Chamfer Tool">
                    <i class="fas fa-vector-square"></i> <!-- Placeholder icon -->
                </button>
            </div>
        </div>
        
        <!-- Action buttons with icons -->
        <button id="deleteButton" class="w-9 h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Delete">
            <i class="fas fa-trash-alt"></i>
        </button>
        <button id="undoButton" class="w-9 h-9 flex items-center justify-center rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200 disabled:opacity-50" disabled aria-label="Undo">
            <i class="fas fa-undo"></i>
        </button>
        <button id="redoButton" class="w-9 h-9 flex items-center justify-center rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200 disabled:opacity-50" disabled aria-label="Redo">
            <i class="fas fa-redo"></i>
        </button>
        <!-- Zoom to Fit Button -->
        <button id="zoomFitButton" class="w-9 h-9 flex items-center justify-center text-lg rounded-md bg-gray-200 text-gray-800 shadow-lg hover:bg-gray-300 focus:outline-none transition-colors duration-200" aria-label="Zoom to Fit">
            <i class="fas fa-compress-arrows-alt"></i>
        </button>

        <!-- Toggles for snap and grid, now with icons -->
        <button id="snapButton" class="w-9 h-9 flex items-center justify-center rounded-md bg-indigo-500 text-white shadow-lg hover:bg-indigo-600 focus:outline-none transition-colors duration-200 active-tool" aria-label="Toggle Snap">
           <i class="fas fa-magnet"></i>
        </button>
        <button id="gridButton" class="w-9 h-9 flex items-center justify-center rounded-md bg-indigo-500 text-white shadow-lg hover:bg-indigo-600 focus:outline-none transition-colors duration-200 active-tool" aria-label="Toggle Grid">
            <i class="fas fa-th"></i>
        </button>
    </div>

    <!-- Main content area for the canvas -->
    <main id="canvas-container">
        <canvas id="myCanvas"></canvas>
    </main>

    <!-- Right Sidebar for Vertical Ads -->
    <aside id="rightSidebar">
        <!-- 
            PASTE YOUR VERTICAL AD CODE HERE
            Recommended size is around 160x600, but the container will hold any size.
        -->
        <div class="h-full border-2 border-dashed border-gray-400 flex items-center justify-center text-center">
            <span class="text-gray-500">Vertical Ad Area (160x600)</span>
        </div>
    </aside>

    <!-- Footer Bar for Horizontal Ads -->
    <footer id="footerBar">
        <!-- 
            PASTE YOUR HORIZONTAL AD CODE HERE
            Recommended sizes are leaderboard (728x90) or large banner (970x90).
        -->
        <div class="h-full border-2 border-dashed border-gray-400 flex items-center justify-center">
            <span class="text-gray-500">Horizontal Ad Area (728x90)</span>
        </div>
    </footer>

    <!-- Custom Context Menu for the line tool -->
    <div id="customContextMenu">
        <div id="endLinesMenuItem" class="context-menu-item">End Drawing</div>
        <div id="deleteMenuItem" class="context-menu-item danger">Delete</div>
    </div>

    <!-- Modal for editing dimensions -->
    <div id="editDimensionModal" class="modal">
        <h3>Edit Dimension</h3>
        <div class="modal-content">
            <label for="dimensionValueInput" id="dimensionLabel">New Value</label>
            <input type="text" id="dimensionValueInput" />
        </div>
        <div class="button-group">
            <button id="cancelEditButton" class="modal-button cancel">Cancel</button>
            <button id="okEditButton" class="modal-button ok">OK</button>
        </div>
    </div>

    <!-- Modal for modifier tools -->
    <div id="modifierModal" class="modal">
        <h3 id="modifierModalTitle" class="text-lg font-bold mb-2">Modifier</h3>
        <div class="modal-content">
            <!-- Common Value Input -->
            <div>
                <label for="modifierValueInput" id="modifierLabel">Value</label>
                <input type="text" id="modifierValueInput" />
            </div>
            <!-- Offset Specific -->
            <div id="offsetOptions" class="mt-2" style="display: none;">
                 <label class="flex items-center gap-2 cursor-pointer">
                    <input type="checkbox" id="inverseOffsetCheckbox" class="w-auto" />
                    <span>Inverse Direction</span>
                </label>
            </div>
            <!-- Chamfer Specific -->
            <div id="chamferOptions" class="mt-2" style="display: none;">
                <label for="chamferAngleInput">Angle (deg)</label>
                <input type="text" id="chamferAngleInput" value="45" />
            </div>
        </div>
        <div class="button-group">
            <button id="cancelModifierButton" class="modal-button cancel">Cancel</button>
            <button id="okModifierButton" class="modal-button ok">OK</button>
        </div>
    </div>
    
    <!-- Draggable Shape Inspector Panel -->
    <div id="shapeInspectorPanel" class="modal">
        <div id="inspectorHeader">Shape Inspector</div>
        <div class="modal-content">
            <div class="inspector-row">
                <label for="lineColorInput">Line Color</label>
                <input type="color" id="lineColorInput" />
            </div>
            <div class="inspector-row">
                <label for="lineWidthInput">Thickness (px)</label>
                <input type="number" id="lineWidthInput" min="1" max="20" />
            </div>
            <div class="inspector-row">
                <label for="lineTypeSelect">Line Type</label>
                <select id="lineTypeSelect">
                    <option value="solid">Solid</option>
                    <option value="dashed">Dashed</option>
                    <option value="construction">Construction</option>
                </select>
            </div>
        </div>
        <div class="button-group">
            <button id="inspectorCancelButton" class="modal-button cancel">Cancel</button>
            <button id="inspectorOkButton" class="modal-button ok">OK</button>
        </div>
    </div>
    
    <script>
        // ===============================================
        // Constants and Global Variables
        // ===============================================
        
        const PIXELS_PER_MM = 15;
        const GRID_SIZE = PIXELS_PER_MM; // Each grid square is 1mm
        const ZOOM_SENSITIVITY = 0.001;
        const CLOSE_LOOP_THRESHOLD = 15;
        const HOVER_TOLERANCE = 10;
        const POINT_HOVER_RADIUS = 5;
        const RECTANGLE_HANDLE_RADIUS = 5;
        const DIMENSION_OFFSET = 20;
        const SNAP_RADIUS = 10; // Radius for snapping to points

        // Get canvas and its 2D drawing context
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');

        // Get all control buttons and menu elements
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const snapButton = document.getElementById('snapButton');
        const gridButton = document.getElementById('gridButton');
        const selectTool = document.getElementById('selectTool');
        const lineTool = document.getElementById('lineTool');
        const rectangleTool = document.getElementById('rectangleTool');
        const circleTool = document.getElementById('circleTool');
        const arcTool = document.getElementById('arcTool');
        const ellipseTool = document.getElementById('ellipseTool');
        const splineTool = document.getElementById('splineTool');
        const dimensionTool = document.getElementById('dimensionTool');
        const coincidentConstraintTool = document.getElementById('coincidentConstraintTool');
        const tangentConstraintTool = document.getElementById('tangentConstraintTool');
        const fixConstraintTool = document.getElementById('fixConstraintTool');
        const horizontalConstraintTool = document.getElementById('horizontalConstraintTool');
        const verticalConstraintTool = document.getElementById('verticalConstraintTool');
        const parallelConstraintTool = document.getElementById('parallelConstraintTool');
        const perpendicularConstraintTool = document.getElementById('perpendicularConstraintTool');
        const collinearConstraintTool = document.getElementById('collinearConstraintTool');
        const trimTool = document.getElementById('trimTool');
        const offsetTool = document.getElementById('offsetTool');
        const filletTool = document.getElementById('filletTool');
        const chamferTool = document.getElementById('chamferTool');
        const deleteButton = document.getElementById('deleteButton');
        const zoomFitButton = document.getElementById('zoomFitButton');
        const customContextMenu = document.getElementById('customContextMenu');
        const endLinesMenuItem = document.getElementById('endLinesMenuItem');
        const deleteMenuItem = document.getElementById('deleteMenuItem');
        const editDimensionModal = document.getElementById('editDimensionModal');
        const dimensionValueInput = document.getElementById('dimensionValueInput');
        const okEditButton = document.getElementById('okEditButton');
        const cancelEditButton = document.getElementById('cancelEditButton');
        const dimensionLabel = document.getElementById('dimensionLabel');
        const modifierModal = document.getElementById('modifierModal');
        const modifierModalTitle = document.getElementById('modifierModalTitle');
        const modifierLabel = document.getElementById('modifierLabel');
        const modifierValueInput = document.getElementById('modifierValueInput');
        const okModifierButton = document.getElementById('okModifierButton');
        const cancelModifierButton = document.getElementById('cancelModifierButton');
        // NEW MODAL ELEMENTS
        const offsetOptions = document.getElementById('offsetOptions');
        const inverseOffsetCheckbox = document.getElementById('inverseOffsetCheckbox');
        const chamferOptions = document.getElementById('chamferOptions');
        const chamferAngleInput = document.getElementById('chamferAngleInput');

        // Dropdown elements
        const drawToolsButton = document.getElementById('drawToolsButton');
        const constraintToolsButton = document.getElementById('constraintToolsButton');
        const modifyToolsButton = document.getElementById('modifyToolsButton');
        const drawToolsDropdown = document.getElementById('drawToolsDropdown');
        const constraintToolsDropdown = document.getElementById('constraintToolsDropdown');
        const modifyToolsDropdown = document.getElementById('modifyToolsDropdown');
        const activeDrawToolIcon = document.getElementById('activeDrawToolIcon');
        const activeConstraintToolIcon = document.getElementById('activeConstraintToolIcon');
        const activeModifyToolIcon = document.getElementById('activeModifyToolIcon');

        // Inspector Panel elements
        const shapeInspectorPanel = document.getElementById('shapeInspectorPanel');
        const inspectorHeader = document.getElementById('inspectorHeader');
        const lineColorInput = document.getElementById('lineColorInput');
        const lineWidthInput = document.getElementById('lineWidthInput');
        const lineTypeSelect = document.getElementById('lineTypeSelect');
        const inspectorOkButton = document.getElementById('inspectorOkButton');
        const inspectorCancelButton = document.getElementById('inspectorCancelButton');

        // State variables for the application
        let isSnapEnabled = true;
        let isGridVisible = true;
        let scale = 1.0;
        let offsetX = 0;
        let offsetY = 0;
        let isPanning = false;
        let lastPointerX = 0;
        let lastPointerY = 0;
        let currentTool = null; // Default to select tool
        let isDraggingShape = false; 
        let dragStartCoords = { x: 0, y: 0 }; 
        let hoveredElement = null;
        let selectedElement = null;
        let lastRightClickedElement = null;
        let tempShape = null;
        let editingDimension = null;
        let editingShape = null;
        let snapPoint = null; // To store current snap point

        let isDraggingDimensionModal = false;
        let dimensionModalOffsetX, dimensionModalOffsetY;

        let tempDimension = null;
        
        // State for constraint creation
        let constraintCreationStep = 0;
        let firstElementForConstraint = null;

        // State for modifier tools
        let modifierStep = 0;
        let firstElementForModifier = null;
        let secondElementForModifier = null; // Added for 2-element modifiers
        
        // State for dimension creation
        let dimensionCreationStep = 0;
        let firstElementForDimension = null;
        let secondElementForDimension = null;


        // Data structures for geometry objects
        let polygons = [];
        let currentPolygonLines = null;
        let circleIdCounter = 0;
        let circles = [];
        let polygonIdCounter = 0;
        let rectangleIdCounter = 0;
        let rectangles = [];
        let dimensionIdCounter = 0;
        let dimensions = [];
        let constraintIdCounter = 0;
        let constraints = [];
        let arcIdCounter = 0;
        let arcs = [];
        let ellipseIdCounter = 0;
        let ellipses = [];
        let splineIdCounter = 0;
        let splines = [];
        let currentSplinePoints = null;

        // History stacks for undo/redo
        let undoStack = [];
        let redoStack = [];

        // ===============================================
        // Initialization and Window Events
        // ===============================================

        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            if (container) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                offsetX = canvas.width / (2 * scale);
                offsetY = canvas.height / (2 * scale);
                draw();
            }
        }
        window.addEventListener('resize', resizeCanvas);
        
        window.onload = function() {
            resizeCanvas();
            saveState();
            draw();
        };
        
        // ===============================================
        // History Management Functions
        // ===============================================

        function saveState() {
            const state = {
                polygons: JSON.parse(JSON.stringify(polygons)),
                circles: JSON.parse(JSON.stringify(circles)),
                rectangles: JSON.parse(JSON.stringify(rectangles)),
                dimensions: JSON.parse(JSON.stringify(dimensions)),
                constraints: JSON.parse(JSON.stringify(constraints)),
                arcs: JSON.parse(JSON.stringify(arcs)),
                ellipses: JSON.parse(JSON.stringify(ellipses)),
                splines: JSON.parse(JSON.stringify(splines)),
            };
            undoStack.push(state);
            redoStack = [];
            updateUndoRedoButtons();
        }

        function restoreState(state) {
            polygons = state.polygons;
            circles = state.circles;
            rectangles = state.rectangles;
            dimensions = state.dimensions;
            constraints = state.constraints;
            arcs = state.arcs;
            ellipses = state.ellipses;
            splines = state.splines;

            selectedElement = null;
            hoveredElement = null;
            applyConstraints();
            draw();
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            undoButton.disabled = undoStack.length <= 1;
            redoButton.disabled = redoStack.length === 0;
        }

        function undo() {
            if (undoStack.length > 1) {
                const undoneState = undoStack.pop();
                redoStack.push(undoneState);
                const previousState = undoStack[undoStack.length - 1];
                restoreState(previousState);
            }
        }
        
        undoButton.addEventListener('click', undo);

        function redo() {
            if (redoStack.length > 0) {
                const redoneState = redoStack.pop();
                undoStack.push(redoneState);
                restoreState(redoneState);
            }
        }
        
        redoButton.addEventListener('click', redo);

        // ===============================================
        // --- NEW --- 3-Point Arc Calculation Function
        // ===============================================
        
        /**
         * Calculates the arc properties (center, radius, start and end angles) from three points.
         * This uses the circumcenter of the triangle formed by the three points.
         * @param {object} p1 - First point {x, y}
         * @param {object} p2 - Second point {x, y}
         * @param {object} p3 - Third point {x, y}
         * @returns {object|null} An object with {x, y, radius, startAngle, endAngle, anticlockwise} or null if points are collinear.
         */
        function calculateArcFromThreePoints(p1, p2, p3) {
            const x1 = p1.x, y1 = p1.y;
            const x2 = p2.x, y2 = p2.y;
            const x3 = p3.x, y3 = p3.y;

            // Check for collinearity using the area of the triangle
            const area = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2);
            if (Math.abs(area) < 1e-6) {
                return null; // Points are collinear
            }

            // Calculate center of the circle (circumcenter)
            const d = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));
            const cx = ((x1*x1 + y1*y1) * (y2 - y3) + (x2*x2 + y2*y2) * (y3 - y1) + (x3*x3 + y3*y3) * (y1 - y2)) / d;
            const cy = ((x1*x1 + y1*y1) * (x3 - x2) + (x2*x2 + y2*y2) * (x1 - x3) + (x3*x3 + y3*y3) * (x2 - x1)) / d;
            const center = { x: cx, y: cy };

            // Calculate radius
            const radius = Math.sqrt(Math.pow(x1 - cx, 2) + Math.pow(y1 - cy, 2));

            // Calculate angles for all three points
            const startAngle = Math.atan2(y1 - cy, x1 - cx);
            const endAngle = Math.atan2(y2 - cy, x2 - cx);
            const middleAngle = Math.atan2(y3 - cy, x3 - cx);

            // Determine if the third point lies on the minor arc drawn counter-clockwise
            const n_start = normalizeAngle(startAngle);
            const n_end = normalizeAngle(endAngle);
            const n_middle = normalizeAngle(middleAngle);

            let p3_on_minor_ccw_arc;
            if (n_start < n_end) {
                p3_on_minor_ccw_arc = (n_middle > n_start && n_middle < n_end);
            } else { // Arc crosses the 0-radian line
                p3_on_minor_ccw_arc = (n_middle > n_start || n_middle < n_end);
            }
            
            // The canvas arc direction is counter-intuitive.
            // We draw CCW if the point is NOT on the minor CCW arc, and vice-versa.
            const anticlockwise = !p3_on_minor_ccw_arc;

            return { x: cx, y: cy, radius, startAngle, endAngle, anticlockwise };
        }
        
        // ===============================================
        // Coordinate System and Drawing Helpers
        // ===============================================
        
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;
            const canvasX = (mouseX / scale) - offsetX;
            const canvasY = (mouseY / scale) - offsetY;
            return { x: canvasX, y: canvasY };
        }
        
        function getScreenCoordinates(x, y) {
            const screenX = (x + offsetX) * scale;
            const screenY = (y + offsetY) * scale;
            return { x: screenX, y: screenY };
        }

        function snapToGrid(coord) {
            return Math.round(coord / GRID_SIZE) * GRID_SIZE;
        }

        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }
        
        function pixelsToMm(pixels) {
            return pixels / PIXELS_PER_MM;
        }
        
        function mmToPixels(mm) {
            return mm * PIXELS_PER_MM;
        }

        function normalizeAngle(angle) {
            let a = angle % (2 * Math.PI);
            return a < 0 ? a + 2 * Math.PI : a;
        }
        
        function drawRulers() {
            ctx.save();
            ctx.translate(offsetX * scale, offsetY * scale);
            ctx.scale(scale, scale);

            const canvasWidth = canvas.width / scale;
            const canvasHeight = canvas.height / scale;

            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2 / scale;
            ctx.beginPath();
            ctx.moveTo(-offsetX, 0);
            ctx.lineTo(-offsetX + canvasWidth, 0);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, -offsetY);
            ctx.lineTo(0, -offsetY + canvasHeight);
            ctx.stroke();

            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(0, 0, 4 / scale, 0, 2 * Math.PI);
            ctx.fill();

            ctx.font = `${10 / scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillStyle = '#000000';
            ctx.lineWidth = 1 / scale;

            const majorTickInterval = PIXELS_PER_MM * 10; // Major tick every 10mm (1cm)
            
            const startX = Math.floor((-offsetX) / majorTickInterval) * majorTickInterval;
            const endX = Math.ceil((canvasWidth - offsetX) / majorTickInterval) * majorTickInterval;
            for (let i = startX; i <= endX; i += majorTickInterval) {
                if (i !== 0) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0 - (5 / scale));
                    ctx.lineTo(i, 0 + (5 / scale));
                    ctx.stroke();
                    ctx.fillText(`${(i / PIXELS_PER_MM).toFixed(0)}mm`, i, 0 + (7 / scale));
                }
            }
            
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            const startY = Math.floor((-offsetY) / majorTickInterval) * majorTickInterval;
            const endY = Math.ceil((canvas.height - offsetY) / majorTickInterval) * majorTickInterval;
            for (let i = startY; i <= endY; i += majorTickInterval) {
                if (i !== 0) {
                    ctx.beginPath();
                    ctx.moveTo(0 - (5 / scale), i);
                    ctx.lineTo(0 + (5 / scale), i);
                    ctx.stroke();
                    ctx.fillText(`${(i / PIXELS_PER_MM).toFixed(0)}mm`, 0 - (7 / scale), i);
                }
            }
            
            ctx.restore();
        }

        // Main drawing function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawRulers();
            
            ctx.save();
            ctx.translate(offsetX * scale, offsetY * scale);
            ctx.scale(scale, scale);

            drawGrid();
            drawPolygons();
            drawCircles();
            drawRectangles();
            drawArcs();
            drawEllipses();
            drawSplines();

            drawDimensions();
            drawConstraints();
            drawTempShape();
            drawSnapPoint();
            
            ctx.restore();
        }

        // ===============================================
        // Drawing Functions for Shapes
        // ===============================================

        function drawGrid() {
            if (isGridVisible) {
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1 / scale;
                const startX = Math.floor((-offsetX * scale) / (GRID_SIZE * scale)) * GRID_SIZE;
                const endX = Math.ceil((canvas.width - offsetX * scale) / (GRID_SIZE * scale)) * GRID_SIZE;
                const startY = Math.floor((-offsetY * scale) / (GRID_SIZE * scale)) * GRID_SIZE;
                const endY = Math.ceil((canvas.height - offsetY * scale) / (GRID_SIZE * scale)) * GRID_SIZE;
                for (let i = startX; i <= endX; i += GRID_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(i, startY);
                    ctx.lineTo(i, endY);
                    ctx.stroke();
                }
                for (let i = startY; i <= endY; i += GRID_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(startX, i);
                    ctx.lineTo(endX, i);
                    ctx.stroke();
                }
            }
        }
        
        function drawPolygons() {
            polygons.forEach(polygon => {
                const isSelected = selectedElement && selectedElement.type === 'polygon' && selectedElement.id === polygon.id;
                const isHovered = hoveredElement && hoveredElement.type === 'polygon' && hoveredElement.id === polygon.id;

                let fillStyle = `rgba(209, 213, 219, 0.45)`;
                let strokeStyle = polygon.color || `rgb(34, 197, 94)`;

                if (isSelected) {
                    strokeStyle = `rgb(22, 163, 74)`;
                } else if (isHovered) {
                    strokeStyle = `rgb(52, 211, 153)`;
                }
                
                if (polygon.isClosed) {
                    ctx.fillStyle = fillStyle;
                    ctx.beginPath();
                    polygon.lines.forEach(line => {
                         if (line.type === 'arc') {
                            ctx.arc(line.cx, line.cy, line.radius, line.startAngle, line.endAngle);
                        } else {
                            ctx.lineTo(line.x1, line.y1);
                        }
                    });
                    const lastLine = polygon.lines[polygon.lines.length-1];
                    if(lastLine.type !== 'arc') ctx.lineTo(lastLine.x2, lastLine.y2);

                    ctx.closePath();
                    ctx.fill();
                }

                if (polygon.lineType === 'dashed') {
                    ctx.setLineDash([5 / scale, 5 / scale]);
                } else if (polygon.lineType === 'construction') {
                    ctx.setLineDash([12 / scale, 3 / scale, 4 / scale, 3 / scale]); // long dash, gap, short dash, gap
                } else {
                    ctx.setLineDash([]);
                }

                polygon.lines.forEach(line => {
                    ctx.strokeStyle = strokeStyle;
                    ctx.lineWidth = (polygon.lineWidth || 2) / scale;
                    ctx.beginPath();
                    if (line.type === 'arc') {
                         // FIX: Use the 'clockwise' property to draw the arc in the correct direction.
                         // The arc() function's last parameter is 'counterclockwise', so we pass the inverse.
                         ctx.arc(line.cx, line.cy, line.radius, line.startAngle, line.endAngle, !line.clockwise);
                    } else {
                        ctx.moveTo(line.x1, line.y1);
                        ctx.lineTo(line.x2, line.y2);
                    }
                    ctx.stroke();
                });
                
                ctx.setLineDash([]);


                if (isHovered || isSelected) {
                    ctx.fillStyle = strokeStyle;
                    ctx.strokeStyle = strokeStyle;
                    ctx.lineWidth = 2 / scale;
                    polygon.lines.forEach(line => {
                        if(line.type !== 'arc') {
                            ctx.beginPath();
                            ctx.arc(line.x1, line.y1, POINT_HOVER_RADIUS / scale, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.stroke();
                        }
                    });
                    const lastLine = polygon.lines[polygon.lines.length - 1];
                     if(lastLine.type !== 'arc') {
                        ctx.beginPath();
                        ctx.arc(lastLine.x2, lastLine.y2, POINT_HOVER_RADIUS / scale, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    }
                }
            });

            if (currentPolygonLines) {
                ctx.strokeStyle = 'rgb(34, 197, 94)';
                ctx.lineWidth = 3 / scale;
                ctx.beginPath();
                ctx.moveTo(currentPolygonLines[0].x1, currentPolygonLines[0].y1);
                currentPolygonLines.forEach(line => ctx.lineTo(line.x2, line.y2));
                ctx.stroke();
                
                ctx.fillStyle = 'rgb(34, 197, 94)';
                ctx.strokeStyle = 'rgb(34, 197, 94)';
                ctx.lineWidth = 2 / scale;
                currentPolygonLines.forEach(line => {
                    ctx.beginPath();
                    ctx.arc(line.x1, line.y1, POINT_HOVER_RADIUS / scale, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                });
                const lastLine = currentPolygonLines[currentPolygonLines.length - 1];
                ctx.beginPath();
                ctx.arc(lastLine.x2, lastLine.y2, POINT_HOVER_RADIUS / scale, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            }
        }

        function drawCircles() {
            circles.forEach(circle => {
                const isSelected = selectedElement && selectedElement.type === 'circle' && selectedElement.id === circle.id;
                const isHovered = hoveredElement && hoveredElement.type === 'circle' && hoveredElement.id === circle.id;

                let fillStyle = `rgba(209, 213, 219, 0.45)`;
                let strokeStyle = circle.color || `rgb(34, 197, 94)`;
                
                if (isSelected) {
                    strokeStyle = `rgb(22, 163, 74)`;
                } else if (isHovered) {
                    strokeStyle = `rgb(52, 211, 153)`;
                }
                
                if (circle.lineType === 'dashed') {
                    ctx.setLineDash([5 / scale, 5 / scale]);
                } else if (circle.lineType === 'construction') {
                    ctx.setLineDash([12 / scale, 3 / scale, 4 / scale, 3 / scale]); // long dash, gap, short dash, gap
                } else {
                    ctx.setLineDash([]);
                }

                ctx.fillStyle = fillStyle;
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = (circle.lineWidth || 2)  / scale;
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                ctx.setLineDash([]);

            });
        }
        
        function drawRectangles() {
            rectangles.forEach(rectangle => {
                const isSelected = selectedElement && selectedElement.type === 'rectangle' && selectedElement.id === rectangle.id;
                const isHovered = hoveredElement && hoveredElement.type === 'rectangle' && hoveredElement.id === rectangle.id;
                
                let fillStyle = `rgba(209, 213, 219, 0.45)`;
                let strokeStyle = rectangle.color || `rgb(34, 197, 94)`;
                
                if (isSelected) {
                    strokeStyle = `rgb(22, 163, 74)`;
                } else if (isHovered) {
                    strokeStyle = `rgb(52, 211, 153)`;
                }
                
                if (rectangle.lineType === 'dashed') {
                    ctx.setLineDash([5 / scale, 5 / scale]);
                } else if (rectangle.lineType === 'construction') {
                    ctx.setLineDash([12 / scale, 3 / scale, 4 / scale, 3 / scale]); // long dash, gap, short dash, gap
                } else {
                    ctx.setLineDash([]);
                }

                ctx.fillStyle = fillStyle;
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = (rectangle.lineWidth || 2) / scale;
                ctx.beginPath();
                ctx.rect(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
                ctx.fill();
                ctx.stroke();
                
                ctx.setLineDash([]);
                
                if (isSelected) {
                    ctx.fillStyle = strokeStyle;
                    const corners = [
                        {x: rectangle.x, y: rectangle.y},
                        {x: rectangle.x + rectangle.width, y: rectangle.y},
                        {x: rectangle.x + rectangle.width, y: rectangle.y + rectangle.height},
                        {x: rectangle.x, y: rectangle.y + rectangle.height}
                    ];
                    corners.forEach(corner => {
                        ctx.beginPath();
                        ctx.arc(corner.x, corner.y, RECTANGLE_HANDLE_RADIUS / scale, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }
            });
        }
        
        function drawArcs() {
            arcs.forEach(arc => {
                const isSelected = selectedElement && selectedElement.type.includes('arc') && selectedElement.shapeId === arc.id;
                const isHovered = hoveredElement && hoveredElement.type.includes('arc') && hoveredElement.shapeId === arc.id;
        
                let strokeStyle = arc.color || `rgb(34, 197, 94)`;
        
                if (isSelected) {
                    strokeStyle = `rgb(22, 163, 74)`;
                } else if (isHovered) {
                    strokeStyle = `rgb(52, 211, 153)`;
                }
        
                if (arc.lineType === 'dashed') {
                    ctx.setLineDash([5 / scale, 5 / scale]);
                } else if (arc.lineType === 'construction') {
                    ctx.setLineDash([12 / scale, 3 / scale, 4 / scale, 3 / scale]);
                } else {
                    ctx.setLineDash([]);
                }
        
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = (arc.lineWidth || 2) / scale;
                ctx.beginPath();
                ctx.arc(arc.cx, arc.cy, arc.radius, arc.startAngle, arc.endAngle, arc.anticlockwise);
                ctx.stroke();
        
                ctx.setLineDash([]);

                // --- NEW --- Draw handles if selected or hovered
                if (isSelected || isHovered) {
                    ctx.fillStyle = strokeStyle;
                    const startPoint = {
                        x: arc.cx + arc.radius * Math.cos(arc.startAngle),
                        y: arc.cy + arc.radius * Math.sin(arc.startAngle)
                    };
                    const endPoint = {
                        x: arc.cx + arc.radius * Math.cos(arc.endAngle),
                        y: arc.cy + arc.radius * Math.sin(arc.endAngle)
                    };

                    // Draw start point handle
                    ctx.beginPath();
                    ctx.arc(startPoint.x, startPoint.y, POINT_HOVER_RADIUS / scale, 0, 2 * Math.PI);
                    ctx.fill();

                    // Draw end point handle
                    ctx.beginPath();
                    ctx.arc(endPoint.x, endPoint.y, POINT_HOVER_RADIUS / scale, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw center point handle (stroked to differentiate)
                    ctx.strokeStyle = strokeStyle;
                    ctx.lineWidth = 1 / scale;
                    ctx.beginPath();
                    ctx.arc(arc.cx, arc.cy, POINT_HOVER_RADIUS / scale, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            });
        }
        
        function drawEllipses() {
            ellipses.forEach(ellipse => {
                const isSelected = selectedElement && selectedElement.type === 'ellipse' && selectedElement.id === ellipse.id;
                const isHovered = hoveredElement && hoveredElement.type === 'ellipse' && hoveredElement.id === ellipse.id;
        
                let fillStyle = `rgba(209, 213, 219, 0.45)`;
                let strokeStyle = ellipse.color || `rgb(34, 197, 94)`;
        
                if (isSelected) {
                    strokeStyle = `rgb(22, 163, 74)`;
                } else if (isHovered) {
                    strokeStyle = `rgb(52, 211, 153)`;
                }
        
                if (ellipse.lineType === 'dashed') {
                    ctx.setLineDash([5 / scale, 5 / scale]);
                } else if (ellipse.lineType === 'construction') {
                    ctx.setLineDash([12 / scale, 3 / scale, 4 / scale, 3 / scale]);
                } else {
                    ctx.setLineDash([]);
                }
        
                ctx.fillStyle = fillStyle;
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = (ellipse.lineWidth || 2) / scale;
                ctx.beginPath();
                ctx.ellipse(ellipse.x, ellipse.y, ellipse.radiusX, ellipse.radiusY, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
        
                ctx.setLineDash([]);
            });
        }
        
        function drawSplines() {
            splines.forEach(spline => {
                if (spline.points.length < 2) return;
        
                const isSelected = selectedElement && selectedElement.type === 'spline' && selectedElement.id === spline.id;
                const isHovered = hoveredElement && hoveredElement.type === 'spline' && hoveredElement.id === spline.id;
        
                let strokeStyle = spline.color || `rgb(34, 197, 94)`;
        
                if (isSelected) {
                    strokeStyle = `rgb(22, 163, 74)`;
                } else if (isHovered) {
                    strokeStyle = `rgb(52, 211, 153)`;
                }
        
                if (spline.lineType === 'dashed') {
                    ctx.setLineDash([5 / scale, 5 / scale]);
                } else if (spline.lineType === 'construction') {
                    ctx.setLineDash([12 / scale, 3 / scale, 4 / scale, 3 / scale]);
                } else {
                    ctx.setLineDash([]);
                }
        
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = (spline.lineWidth || 2) / scale;
                ctx.beginPath();
        
                // Draw Catmull-Rom Spline
                ctx.moveTo(spline.points[0].x, spline.points[0].y);
                for (let i = 0; i < spline.points.length - 1; i++) {
                    const p0 = spline.points[i === 0 ? 0 : i - 1];
                    const p1 = spline.points[i];
                    const p2 = spline.points[i + 1];
                    const p3 = spline.points[i + 2 < spline.points.length ? i + 2 : spline.points.length - 1];
        
                    const cp1 = {
                        x: p1.x + (p2.x - p0.x) / 6,
                        y: p1.y + (p2.y - p0.y) / 6
                    };
                    const cp2 = {
                        x: p2.x - (p3.x - p1.x) / 6,
                        y: p2.y - (p3.y - p1.y) / 6
                    };
        
                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p2.x, p2.y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
        
                // Draw control points when selected/hovered
                if (isSelected || isHovered) {
                    ctx.fillStyle = strokeStyle;
                    spline.points.forEach(p => {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, POINT_HOVER_RADIUS / scale, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }
            });
        
            if (currentSplinePoints) {
                ctx.strokeStyle = 'rgb(34, 197, 94)';
                ctx.lineWidth = 3 / scale;
                ctx.setLineDash([3 / scale, 3 / scale]);
                ctx.beginPath();
                ctx.moveTo(currentSplinePoints[0].x, currentSplinePoints[0].y);
                for (let i = 1; i < currentSplinePoints.length; i++) {
                    ctx.lineTo(currentSplinePoints[i].x, currentSplinePoints[i].y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }


        function drawArrowhead(fromX, fromY, toX, toY, color) {
            const angle = Math.atan2(toY - fromY, toX - fromX);
            const headlen = 10 / scale;
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function getDimensionDrawingData(dim) {
            let data = {
                type: dim.dimensionType,
                p1: null, p2: null,
                value: 0,
                midX: 0, midY: 0,
                angle: 0
            };
            
            if (dim.dimensionType === 'diameter') {
                const circle = findShapeById(dim.element1.shapeId, 'circle');
                if (!circle) return null;
                data.value = circle.radius * 2;
                data.angle = dim.angle;
                const cosA = Math.cos(data.angle);
                const sinA = Math.sin(data.angle);
                data.p1 = { x: circle.x - cosA * circle.radius, y: circle.y - sinA * circle.radius };
                data.p2 = { x: circle.x + cosA * circle.radius, y: circle.y + sinA * circle.radius };
                data.midX = circle.x;
                data.midY = circle.y;
            } else if (dim.dimensionType === 'radius') {
                const arc = findShapeById(dim.element1.shapeId, 'arc');
                if (!arc) return null;
                data.value = arc.radius;
                data.angle = dim.angle;
                const cosA = Math.cos(data.angle);
                const sinA = Math.sin(data.angle);
                data.p1 = { x: arc.cx, y: arc.cy };
                data.p2 = { x: arc.cx + cosA * arc.radius, y: arc.cy + sinA * arc.radius };
                data.midX = arc.cx + cosA * arc.radius / 2;
                data.midY = arc.cy + sinA * arc.radius / 2;
            } else if (dim.dimensionType === 'ellipse_radiusX' || dim.dimensionType === 'ellipse_radiusY') {
                const ellipse = findShapeById(dim.element1.shapeId, 'ellipse');
                if (!ellipse) return null;
                const isX = dim.dimensionType === 'ellipse_radiusX';
                data.value = isX ? ellipse.radiusX : ellipse.radiusY;
                data.angle = isX ? 0 : Math.PI / 2;
                data.p1 = { x: ellipse.x, y: ellipse.y };
                data.p2 = isX ? { x: ellipse.x + ellipse.radiusX, y: ellipse.y } : { x: ellipse.x, y: ellipse.y + ellipse.radiusY };
                data.midX = isX ? ellipse.x + ellipse.radiusX / 2 : ellipse.x + dim.offset;
                data.midY = isX ? ellipse.y + dim.offset : ellipse.y + ellipse.radiusY / 2;
            } else if (dim.dimensionType === 'angle') {
                const line1 = getLineFromElementInfo(dim.element1);
                const line2 = getLineFromElementInfo(dim.element2);
                if (!line1 || !line2) return null;

                const intersection = findLineIntersection(line1, line2, false); // Use infinite lines
                if (!intersection) return null;

                // Vectors pointing away from the intersection for consistent angle calculation
                const p1_start = {x: line1.x1, y: line1.y1};
                const p1_end = {x: line1.x2, y: line1.y2};
                const p2_start = {x: line2.x1, y: line2.y1};
                const p2_end = {x: line2.x2, y: line2.y2};

                const v1_vec = getDistance(intersection, p1_start) > getDistance(intersection, p1_end) ? {x: p1_start.x - intersection.x, y: p1_start.y - intersection.y} : {x: p1_end.x - intersection.x, y: p1_end.y - intersection.y};
                const v2_vec = getDistance(intersection, p2_start) > getDistance(intersection, p2_end) ? {x: p2_start.x - intersection.x, y: p2_start.y - intersection.y} : {x: p2_end.x - intersection.x, y: p2_end.y - intersection.y};

                let angle1 = Math.atan2(v1_vec.y, v1_vec.x);
                let angle2 = Math.atan2(v2_vec.y, v2_vec.x);

                let innerValue = Math.abs(normalizeAngle(angle2 - angle1));
                if (innerValue > Math.PI) innerValue = 2 * Math.PI - innerValue;

                data.value = dim.isReflex ? (2 * Math.PI - innerValue) : innerValue;
                
                // Determine the drawing order for the arc
                const cross_v1_v2 = v1_vec.x * v2_vec.y - v1_vec.y * v2_vec.x;
                if (cross_v1_v2 < 0) {
                    [angle1, angle2] = [angle2, angle1]; // Ensure inner angle is drawn CCW
                }

                if (dim.isReflex) {
                    data.startAngle = angle2;
                    data.endAngle = angle1 + (2 * Math.PI);
                } else {
                    data.startAngle = angle1;
                    data.endAngle = angle2;
                }

                data.p1 = intersection;
                data.midX = intersection.x;
                data.midY = intersection.y;
            } else { // Linear dimensions
                data.p1 = getPointFromElementInfo(dim.element1);
                if (dim.element2) {
                    data.p2 = getPointFromElementInfo(dim.element2);
                } else {
                    const line = getLineFromElementInfo(dim.element1);
                    if (!line) return null;
                    data.p1 = {x: line.x1, y: line.y1};
                    data.p2 = {x: line.x2, y: line.y2};
                }

                if (!data.p1 || !data.p2) return null;

                if (dim.dimensionType === 'horizontal') {
                    data.value = Math.abs(data.p2.x - data.p1.x);
                    data.angle = 0;
                    data.midX = (data.p1.x + data.p2.x) / 2;
                    data.midY = data.p1.y + dim.offset;
                } else if (dim.dimensionType === 'vertical') {
                    data.value = Math.abs(data.p2.y - data.p1.y);
                    data.angle = Math.PI / 2;
                    data.midX = data.p1.x + dim.offset;
                    data.midY = (data.p1.y + data.p2.y) / 2;
                } else { // Aligned or single Line
                    data.value = getDistance(data.p1, data.p2);
                    data.angle = Math.atan2(data.p2.y - data.p1.y, data.p2.x - data.p1.x);
                    const perpAngle = data.angle + Math.PI / 2;
                    data.midX = (data.p1.x + data.p2.x) / 2 + Math.cos(perpAngle) * dim.offset;
                    data.midY = (data.p1.y + data.p2.y) / 2 + Math.sin(perpAngle) * dim.offset;
                }
            }
            return data;
        }


        function drawDimensions() {
            const dimensionsToDraw = tempDimension ? [...dimensions, tempDimension] : dimensions;

            dimensionsToDraw.forEach(dim => {
                const isSelected = selectedElement && selectedElement.type === 'dimension' && selectedElement.id === dim.id;
                const isHovered = hoveredElement && hoveredElement.type === 'dimension' && hoveredElement.id === dim.id;
                const isTemp = !dim.hasOwnProperty('id');

                const dimData = getDimensionDrawingData(dim);
                if (!dimData) return;

                const color = isSelected || isHovered ? '#4338ca' : '#4f46e5';
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = isSelected || isHovered || isTemp ? 1.5 / scale : 1 / scale;
                ctx.font = `${12 / scale}px Arial`;
                if (isTemp) ctx.setLineDash([5 / scale, 5 / scale]);

                if (dimData.type === 'diameter') {
                    const text = `Ø ${pixelsToMm(dimData.value).toFixed(2)}mm`;
                    ctx.beginPath();
                    ctx.moveTo(dimData.p1.x, dimData.p1.y);
                    ctx.lineTo(dimData.p2.x, dimData.p2.y);
                    ctx.stroke();
                    drawArrowhead(dimData.p2.x, dimData.p2.y, dimData.p1.x, dimData.p1.y, color);
                    drawArrowhead(dimData.p1.x, dimData.p1.y, dimData.p2.x, dimData.p2.y, color);
                    ctx.save();
                    ctx.translate(dimData.midX, dimData.midY);
                    ctx.rotate(dimData.angle > Math.PI / 2 || dimData.angle < -Math.PI / 2 ? dimData.angle - Math.PI : dimData.angle);
                    ctx.clearRect(-ctx.measureText(text).width / 2 - 2/scale, -8/scale, ctx.measureText(text).width + 4/scale, 16/scale);
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(text, 0, 0);
                    ctx.restore();
                } else if (dimData.type === 'angle') {
                    const text = `${(dimData.value * 180 / Math.PI).toFixed(2)}°`;
                    ctx.beginPath();
                    ctx.arc(dimData.p1.x, dimData.p1.y, dim.offset, dimData.startAngle, dimData.endAngle);
                    ctx.stroke();

                    // Add arrowheads to the arc
                    const startPoint = {
                        x: dimData.p1.x + dim.offset * Math.cos(dimData.startAngle),
                        y: dimData.p1.y + dim.offset * Math.sin(dimData.startAngle)
                    };
                    const endPoint = {
                        x: dimData.p1.x + dim.offset * Math.cos(dimData.endAngle),
                        y: dimData.p1.y + dim.offset * Math.sin(dimData.endAngle)
                    };

                    const endTangentAngle = dimData.endAngle + Math.PI / 2;
                    const endFrom = {
                        x: endPoint.x - (10/scale) * Math.cos(endTangentAngle),
                        y: endPoint.y - (10/scale) * Math.sin(endTangentAngle)
                    };
                    drawArrowhead(endFrom.x, endFrom.y, endPoint.x, endPoint.y, color);

                    const startTangentAngle = dimData.startAngle - Math.PI / 2;
                    const startFrom = {
                        x: startPoint.x - (10/scale) * Math.cos(startTangentAngle),
                        y: startPoint.y - (10/scale) * Math.sin(startTangentAngle)
                    };
                    drawArrowhead(startFrom.x, startFrom.y, startPoint.x, startPoint.y, color);

                    const textAngle = dimData.startAngle + (dimData.endAngle - dimData.startAngle) / 2;
                    const textX = dimData.p1.x + Math.cos(textAngle) * (dim.offset + 18 / scale);
                    const textY = dimData.p1.y + Math.sin(textAngle) * (dim.offset + 18 / scale);
                    ctx.save();
                    ctx.translate(textX, textY);
                    ctx.rotate(textAngle > Math.PI / 2 || textAngle < -Math.PI / 2 ? textAngle - Math.PI : textAngle);
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(text, 0, 0);
                    ctx.restore();
                } else { // All linear types
                    const text = `${pixelsToMm(dimData.value).toFixed(2)}mm`;
                    const textWidth = ctx.measureText(text).width;
                    const cosA = Math.cos(dimData.angle);
                    const sinA = Math.sin(dimData.angle);

                    // Dimension line points
                    const dimLineP1 = { x: dimData.midX - cosA * dimData.value / 2, y: dimData.midY - sinA * dimData.value / 2 };
                    const dimLineP2 = { x: dimData.midX + cosA * dimData.value / 2, y: dimData.midY + sinA * dimData.value / 2 };

                    // Extension lines
                    ctx.beginPath();
                    if (dim.dimensionType === 'horizontal') {
                        ctx.moveTo(dimData.p1.x, dimData.p1.y); ctx.lineTo(dimData.p1.x, dimData.midY);
                        ctx.moveTo(dimData.p2.x, dimData.p2.y); ctx.lineTo(dimData.p2.x, dimData.midY);
                    } else if (dim.dimensionType === 'vertical') {
                        ctx.moveTo(dimData.p1.x, dimData.p1.y); ctx.lineTo(dimData.midX, dimData.p1.y);
                        ctx.moveTo(dimData.p2.x, dimData.p2.y); ctx.lineTo(dimData.midX, dimData.p2.y);
                    } else { // Aligned or single line
                        ctx.moveTo(dimData.p1.x, dimData.p1.y); ctx.lineTo(dimLineP1.x, dimLineP1.y);
                        ctx.moveTo(dimData.p2.x, dimData.p2.y); ctx.lineTo(dimLineP2.x, dimLineP2.y);
                    }
                    ctx.stroke();

                    // Main dimension line (with gap for text)
                    const totalGap = textWidth + 10 / scale;
                    const startGap = { x: dimData.midX - cosA * (totalGap / 2), y: dimData.midY - sinA * (totalGap / 2) };
                    const endGap = { x: dimData.midX + cosA * (totalGap / 2), y: dimData.midY + sinA * (totalGap / 2) };
                    ctx.beginPath();
                    ctx.moveTo(dimLineP1.x, dimLineP1.y); ctx.lineTo(startGap.x, startGap.y);
                    ctx.moveTo(endGap.x, endGap.y); ctx.lineTo(dimLineP2.x, dimLineP2.y);
                    ctx.stroke();

                    drawArrowhead(dimLineP2.x, dimLineP2.y, dimLineP1.x, dimLineP1.y, color);
                    drawArrowhead(dimLineP1.x, dimLineP1.y, dimLineP2.x, dimLineP2.y, color);

                    ctx.save();
                    ctx.translate(dimData.midX, dimData.midY);
                    ctx.rotate(dimData.angle > Math.PI / 2 || dimData.angle < -Math.PI / 2 ? dimData.angle - Math.PI : dimData.angle);
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(text, 0, -2 / scale);
                    ctx.restore();
                }

                if(isTemp) ctx.setLineDash([]);
            });
        }
        
        function drawConstraints() {
            constraints.forEach(constraint => {
                if (constraint.type === 'coincident') {
                    // Not drawing for now to reduce clutter
                } else if (constraint.type === 'tangent') {
                    const shape1 = findShapeById(constraint.element1.shapeId, constraint.element1.shapeType);
                    const shape2 = findShapeById(constraint.element2.shapeId, constraint.element2.shapeType);
                    if (!shape1 || !shape2) return;
                    
                    let tangentPoint;
                    if (shape1.type === 'circle' && shape2.type === 'circle') {
                        const angle = Math.atan2(shape2.y - shape1.y, shape2.x - shape1.x);
                        tangentPoint = {
                            x: shape1.x + Math.cos(angle) * shape1.radius,
                            y: shape1.y + Math.sin(angle) * shape1.radius
                        };
                    } else {
                        const circle = shape1.type === 'circle' ? shape1 : shape2;
                        const lineShape = shape1.type !== 'circle' ? shape1 : shape2;
                        const lineInfo = shape1.type !== 'circle' ? constraint.element1 : constraint.element2;
                        let line;
                        if (lineShape.type === 'polygon') {
                            line = lineShape.lines[lineInfo.lineIndex];
                        } else if (lineShape.type === 'rectangle') {
                            const r = lineShape;
                            const sides = [
                                { name: 'top', x1: r.x, y1: r.y, x2: r.x + r.width, y2: r.y },
                                { name: 'right', x1: r.x + r.width, y1: r.y, x2: r.x + r.width, y2: r.y + r.height },
                                { name: 'bottom', x1: r.x + r.width, y1: r.y + r.height, x2: r.x, y2: r.y + r.height },
                                { name: 'left', x1: r.x, y1: r.y + r.height, x2: r.x, y2: r.y }
                            ];
                            line = sides.find(s => s.name === lineInfo.side);
                        }
                        if (line) {
                            const closestPoint = getClosestPointOnLineSegment(circle.x, circle.y, line.x1, line.y1, line.x2, line.y2);
                            tangentPoint = closestPoint;
                        }
                    }
                    
                    if (tangentPoint) {
                        ctx.strokeStyle = '#c026d3'; // Magenta for tangent
                        ctx.fillStyle = '#c026d3';
                        ctx.lineWidth = 1.5 / scale;
                        ctx.font = `bold ${14 / scale}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('T', tangentPoint.x, tangentPoint.y);
                    }
                } else if (constraint.type === 'horizontal' || constraint.type === 'vertical') {
                    const line = getLineFromElementInfo(constraint.element1);
                    if (line) {
                        const midX = (line.x1 + line.x2) / 2;
                        const midY = (line.y1 + line.y2) / 2;
                        
                        ctx.strokeStyle = '#2563eb'; // Blue for H/V constraints
                        ctx.lineWidth = 1.5 / scale;
                        
                        ctx.beginPath();
                        if (constraint.type === 'horizontal') {
                            ctx.moveTo(midX - 5 / scale, midY);
                            ctx.lineTo(midX + 5 / scale, midY);
                        } else { // vertical
                            ctx.moveTo(midX, midY - 5 / scale);
                            ctx.lineTo(midX, midY + 5 / scale);
                        }
                        ctx.stroke();
                    }
                } else if (constraint.type === 'fix') {
                    const point = getPointFromElementInfo(constraint.element1);
                    if (point) {
                        ctx.strokeStyle = '#16a34a'; // Green for fix constraint
                        ctx.lineWidth = 1.5 / scale;
                        
                        // Simple anchor-like symbol
                        const size = 8 / scale;
                        ctx.beginPath();
                        ctx.arc(point.x, point.y - size / 4, size / 2, 0, Math.PI, true); // Top arc
                        ctx.moveTo(point.x, point.y + size / 4);
                        ctx.lineTo(point.x, point.y - size); // Vertical line
                        ctx.moveTo(point.x - size / 2, point.y - size);
                        ctx.lineTo(point.x + size / 2, point.y - size); // Horizontal bar
                        ctx.stroke();
                    }
                } else if (constraint.type === 'alignHorizontal' || constraint.type === 'alignVertical') {
                    const p1 = getPointFromElementInfo(constraint.element1);
                    const p2 = getPointFromElementInfo(constraint.element2);
                    if (p1 && p2) {
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        
                        ctx.strokeStyle = '#2563eb'; // Blue for H/V constraints
                        ctx.lineWidth = 1.5 / scale;
                        
                        const symbolSize = 5 / scale;
                        ctx.beginPath();
                        if (constraint.type === 'alignHorizontal') {
                            ctx.moveTo(midX - symbolSize, midY);
                            ctx.lineTo(midX + symbolSize, midY);
                        } else { // alignVertical
                            ctx.moveTo(midX, midY - symbolSize);
                            ctx.lineTo(midX, midY + symbolSize);
                        }
                        ctx.stroke();
                    }
                } else if (constraint.type === 'parallel') {
                    const line1 = getLineFromElementInfo(constraint.element1);
                    const line2 = getLineFromElementInfo(constraint.element2);
                    if (line1 && line2) {
                        // Draw symbol near midpoint of each line
                        [line1, line2].forEach(line => {
                            const midX = (line.x1 + line.x2) / 2;
                            const midY = (line.y1 + line.y2) / 2;
                            ctx.save();
                            ctx.translate(midX, midY);
                            ctx.rotate(Math.atan2(line.y2 - line.y1, line.x2 - line.x1));
                            ctx.strokeStyle = '#f59e0b'; // Amber
                            ctx.lineWidth = 1.5 / scale;
                            const size = 6 / scale;
                            ctx.beginPath();
                            ctx.moveTo(-size, -size / 2);
                            ctx.lineTo(size, -size / 2);
                            ctx.moveTo(-size, size / 2);
                            ctx.lineTo(size, size / 2);
                            ctx.stroke();
                            ctx.restore();
                        });
                    }
                } else if (constraint.type === 'perpendicular') {
                    const line1 = getLineFromElementInfo(constraint.element1);
                    const line2 = getLineFromElementInfo(constraint.element2);
                    const intersection = findLineIntersection(line1, line2, false);
                    if (intersection) {
                        ctx.strokeStyle = '#8b5cf6'; // Violet
                        ctx.lineWidth = 1.5 / scale;
                        const size = 6 / scale;
                        const angle1 = Math.atan2(line1.y2 - line1.y1, line1.x2 - line1.x1);
                        
                        ctx.beginPath();
                        ctx.moveTo(intersection.x + Math.cos(angle1) * size, intersection.y + Math.sin(angle1) * size);
                        ctx.lineTo(intersection.x + Math.cos(angle1) * size + Math.cos(angle1 + Math.PI / 2) * size, intersection.y + Math.sin(angle1) * size + Math.sin(angle1 + Math.PI / 2) * size);
                        ctx.lineTo(intersection.x + Math.cos(angle1 + Math.PI / 2) * size, intersection.y + Math.sin(angle1 + Math.PI / 2) * size);
                        ctx.stroke();
                    }
                } else if (constraint.type === 'collinear') {
                    // Draw symbol near midpoint of each line
                    [constraint.element1, constraint.element2].forEach(el => {
                        const line = getLineFromElementInfo(el);
                        if(line) {
                            const midX = (line.x1 + line.x2) / 2;
                            const midY = (line.y1 + line.y2) / 2;
                            ctx.strokeStyle = '#10b981'; // Emerald
                            ctx.lineWidth = 1.5 / scale;
                            ctx.font = `bold ${14 / scale}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('C', midX, midY);
                        }
                    });
                }
            });
        }

        function drawTempShape() {
            if (tempShape) {
                ctx.lineWidth = 2 / scale;
                ctx.setLineDash([5 / scale, 5 / scale]);

                if (tempShape.type === 'circle') {
                    ctx.strokeStyle = '#ef4444';
                    ctx.beginPath();
                    ctx.arc(tempShape.x, tempShape.y, tempShape.radius, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (tempShape.type === 'rectangle') {
                    ctx.strokeStyle = '#4f46e5';
                    ctx.beginPath();
                    ctx.rect(tempShape.x, tempShape.y, tempShape.width, tempShape.height);
                    ctx.stroke();
                } else if (tempShape.type === 'ellipse') {
                    ctx.strokeStyle = '#de73ff';
                    ctx.beginPath();
                    ctx.ellipse(tempShape.x, tempShape.y, tempShape.radiusX, tempShape.radiusY, 0, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (tempShape.type === 'arc') {
                    // --- MODIFIED --- Draw preview for 3-point arc
                    ctx.strokeStyle = '#ff7373';
                    ctx.fillStyle = '#ff7373';
                    ctx.setLineDash([3 / scale, 3 / scale]);

                    if (tempShape.step === 1) { // Drawing line from p1 to mouse
                        ctx.beginPath();
                        ctx.moveTo(tempShape.p1.x, tempShape.p1.y);
                        ctx.lineTo(tempShape.mousePos.x, tempShape.mousePos.y);
                        ctx.stroke();
                        // Draw p1
                        ctx.beginPath();
                        ctx.arc(tempShape.p1.x, tempShape.p1.y, POINT_HOVER_RADIUS / scale, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (tempShape.step === 2) { // Drawing arc preview
                        const arcParams = calculateArcFromThreePoints(tempShape.p1, tempShape.p2, tempShape.mousePos);
                        if (arcParams) {
                            ctx.beginPath();
                            ctx.arc(arcParams.x, arcParams.y, arcParams.radius, arcParams.startAngle, arcParams.endAngle, arcParams.anticlockwise);
                            ctx.stroke();
                        }
                        // Also draw the baseline
                        ctx.beginPath();
                        ctx.moveTo(tempShape.p1.x, tempShape.p1.y);
                        ctx.lineTo(tempShape.p2.x, tempShape.p2.y);
                        ctx.stroke();

                        // Draw p1 and p2
                        ctx.beginPath();
                        ctx.arc(tempShape.p1.x, tempShape.p1.y, POINT_HOVER_RADIUS / scale, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(tempShape.p2.x, tempShape.p2.y, POINT_HOVER_RADIUS / scale, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }

                ctx.setLineDash([]);
            }
        }

        function drawSnapPoint() {
            if (snapPoint) {
                ctx.strokeStyle = '#3b82f6'; // Blue for snap point
                ctx.lineWidth = 2 / scale;
                ctx.beginPath();
                ctx.arc(snapPoint.x, snapPoint.y, (POINT_HOVER_RADIUS + 2) / scale, 0, 2 * Math.PI);
                ctx.stroke();
            }
        }

        // ===============================================
        // Collision/Hover/Snap Detection Functions
        // ===============================================
        
        function getDistanceFromLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const l2 = dx * dx + dy * dy;
            if (l2 === 0) return Math.sqrt(Math.pow(px - x1, 2) + Math.pow(py - y1, 2));
            let t = ((px - x1) * dx + (py - y1) * dy) / l2;
            t = Math.max(0, Math.min(1, t));
            const projectionX = x1 + t * dx;
            const projectionY = y1 + t * dy;
            return Math.sqrt(Math.pow(px - projectionX, 2) + Math.pow(py - projectionY, 2));
        }
        
        function isMouseOverPolygon(x, y) {
            for (const polygon of polygons) {
                for (const line of polygon.lines) {
                    if (line.type === 'arc') {
                         const dist = getDistance({x,y}, {x:line.cx, y:line.cy});
                         if(Math.abs(dist - line.radius) < HOVER_TOLERANCE / scale) return polygon;
                    } else {
                        if (getDistanceFromLineSegment(x, y, line.x1, line.y1, line.x2, line.y2) < HOVER_TOLERANCE / scale) return polygon;
                    }
                }
            }
            return null;
        }

        function getPolylineSegmentAt(x, y) {
            for (const polygon of polygons) {
                for (let i = 0; i < polygon.lines.length; i++) {
                    const line = polygon.lines[i];
                     if (line.type === 'arc') {
                         const dist = getDistance({x,y}, {x:line.cx, y:line.cy});
                         if(Math.abs(dist - line.radius) < HOVER_TOLERANCE / scale) {
                             return { polygonId: polygon.id, lineIndex: i, type: 'arc' };
                         }
                    } else {
                        if (getDistanceFromLineSegment(x, y, line.x1, line.y1, line.x2, line.y2) < HOVER_TOLERANCE / scale) {
                            return { polygonId: polygon.id, lineIndex: i, x1: line.x1, y1: line.y1, x2: line.x2, y2: line.y2, type: 'line' };
                        }
                    }
                }
            }
            return null;
        }
        
        function getRectangleSideAt(x, y) {
            for (const rect of rectangles) {
                 const sides = [
                    { name: 'top', x1: rect.x, y1: rect.y, x2: rect.x + rect.width, y2: rect.y },
                    { name: 'right', x1: rect.x + rect.width, y1: rect.y, x2: rect.x + rect.width, y2: rect.y + rect.height },
                    { name: 'bottom', x1: rect.x + rect.width, y1: rect.y + rect.height, x2: rect.x, y2: rect.y + rect.height },
                    { name: 'left', x1: rect.x, y1: rect.y + rect.height, x2: rect.x, y2: rect.y }
                 ];
                 for (const side of sides) {
                     if (getDistanceFromLineSegment(x, y, side.x1, side.y1, side.x2, side.y2) < HOVER_TOLERANCE / scale) {
                         return { rectangleId: rect.id, side: side.name };
                     }
                 }
            }
            return null;
        }
        
        function isMouseOverCircle(x, y) {
            for (const circle of circles) {
                const dist = getDistance({x,y}, {x:circle.x, y:circle.y});
                if (Math.abs(dist - circle.radius) < HOVER_TOLERANCE / scale) return circle;
            }
            return null;
        }

        function isMouseOverArc(x, y) {
             for (const arc of arcs) {
                const dist = getDistance({x, y}, {x: arc.cx, y: arc.cy});
                if (Math.abs(dist - arc.radius) < HOVER_TOLERANCE / scale) {
                    let angle = normalizeAngle(Math.atan2(y - arc.cy, x - arc.cx));
                    let start = normalizeAngle(arc.startAngle);
                    let end = normalizeAngle(arc.endAngle);
                    
                    // --- FIXED --- More robust angle checking
                    let inRange = false;
                    if (arc.anticlockwise) { // Counter-clockwise
                        if (start < end) {
                            inRange = (angle >= start && angle <= end);
                        } else { // Arc crosses 0
                            inRange = (angle >= start || angle <= end);
                        }
                    } else { // Clockwise
                        if (start > end) {
                            inRange = (angle <= start && angle >= end);
                        } else { // Arc crosses 0
                            inRange = (angle <= start || angle >= end);
                        }
                    }
                    if (inRange) return arc;
                }
            }
            return null;
        }

        function isMouseOverEllipse(x, y) {
            for (const ellipse of ellipses) {
                const dx = x - ellipse.x;
                const dy = y - ellipse.y;
                // Check if point is inside ellipse
                if ((dx * dx) / (ellipse.radiusX * ellipse.radiusX) + (dy * dy) / (ellipse.radiusY * ellipse.radiusY) <= 1) {
                    return ellipse;
                }
            }
            return null;
        }

        function isMouseOverSpline(x, y) {
            for (const spline of splines) {
                for (let i = 0; i < spline.points.length - 1; i++) {
                    // Simple check against line segments for now. A more accurate check would be complex.
                    if (getDistanceFromLineSegment(x, y, spline.points[i].x, spline.points[i].y, spline.points[i+1].x, spline.points[i+1].y) < HOVER_TOLERANCE / scale) {
                        return spline;
                    }
                }
            }
            return null;
        }
        
        function isMouseOverRectangle(x, y) {
            for (const rect of rectangles) {
                if (x > rect.x && x < rect.x + rect.width && y > rect.y && y < rect.y + rect.height) return rect;
            }
            return null;
        }

        function isMouseOverDimension(x, y) {
            for (const dim of dimensions) {
                const dimData = getDimensionDrawingData(dim);
                if (!dimData) continue;
                 if (dimData.type === 'angle') {
                    const dist = getDistance(dimData.p1, {x,y});
                    if (Math.abs(dist - dim.offset) < HOVER_TOLERANCE / scale) return dim;
                } else {
                    const dimLineAngle = dimData.angle;
                    const cosA = Math.cos(dimLineAngle);
                    const sinA = Math.sin(dimLineAngle);
                    const p1 = { x: dimData.midX - cosA * dimData.value / 2, y: dimData.midY - sinA * dimData.value / 2 };
                    const p2 = { x: dimData.midX + cosA * dimData.value / 2, y: dimData.midY + sinA * dimData.value / 2 };
                    if (getDistanceFromLineSegment(x, y, p1.x, p1.y, p2.x, p2.y) < HOVER_TOLERANCE / scale) return dim;
                }
            }
            return null;
        }
        
        function findShapeAt(x, y) {
            const hoveredDimension = isMouseOverDimension(x, y);
            if (hoveredDimension) return { id: hoveredDimension.id, type: 'dimension' };
            
            const hoveredArc = isMouseOverArc(x, y);
            if (hoveredArc) return { id: hoveredArc.id, type: 'arc' };
            
            const hoveredSpline = isMouseOverSpline(x, y);
            if (hoveredSpline) return { id: hoveredSpline.id, type: 'spline' };
            
            const hoveredPolygon = isMouseOverPolygon(x, y);
            if (hoveredPolygon) return { id: hoveredPolygon.id, type: 'polygon' };
            
            const hoveredCircle = isMouseOverCircle(x, y);
            if (hoveredCircle) return { id: hoveredCircle.id, type: 'circle' };
            
            const hoveredEllipse = isMouseOverEllipse(x, y);
            if (hoveredEllipse) return { id: hoveredEllipse.id, type: 'ellipse' };

            const hoveredRectangle = isMouseOverRectangle(x, y);
            if (hoveredRectangle) return { id: hoveredRectangle.id, type: 'rectangle' };

            return null;
        }

        function findShapeById(id, type) {
            switch (type) {
                case 'rectangle': return rectangles.find(r => r.id === id);
                case 'circle': return circles.find(c => c.id === id);
                case 'polygon': return polygons.find(p => p.id === id);
                case 'dimension': return dimensions.find(d => d.id === id);
                case 'arc': return arcs.find(a => a.id === id);
                case 'ellipse': return ellipses.find(e => e.id === id);
                case 'spline': return splines.find(s => s.id === id);
                default: return null;
            }
        }

        function findSnapPoint(x, y) {
            let closestPoint = null;
            let minDistance = SNAP_RADIUS / scale;

            const checkPoint = (p) => {
                const dist = getDistance({x, y}, p);
                if (dist < minDistance) {
                    minDistance = dist;
                    closestPoint = p;
                }
            };

            polygons.forEach(p => {
                p.lines.forEach(l => {
                    if (l.type !== 'arc') {
                        checkPoint({x: l.x1, y: l.y1});
                        checkPoint({x: l.x2, y: l.y2});
                    }
                });
            });

            rectangles.forEach(r => {
                checkPoint({x: r.x, y: r.y});
                checkPoint({x: r.x + r.width, y: r.y});
                checkPoint({x: r.x, y: r.y + r.height});
                checkPoint({x: r.x + r.width, y: r.y + r.height});
            });

            circles.forEach(c => checkPoint({x: c.x, y: c.y}));
            arcs.forEach(a => checkPoint({x: a.cx, y: a.cy}));
            ellipses.forEach(e => checkPoint({x: e.x, y: e.y}));
            splines.forEach(s => s.points.forEach(p => checkPoint(p)));

            return closestPoint;
        }
        
        function getGeometricElementAt(x, y) {
            // Priority 1: Points (vertices, centers)
            for (const p of polygons) {
                for (let i = 0; i < p.lines.length; i++) {
                     if(p.lines[i].type !== 'arc') {
                        if (getDistance({x, y}, {x: p.lines[i].x1, y: p.lines[i].y1}) < HOVER_TOLERANCE / scale) return { type: 'point', shapeType: 'polygon', shapeId: p.id, lineIndex: i, pointType: 'start' };
                        if (getDistance({x, y}, {x: p.lines[i].x2, y: p.lines[i].y2}) < HOVER_TOLERANCE / scale) return { type: 'point', shapeType: 'polygon', shapeId: p.id, lineIndex: i, pointType: 'end' };
                     }
                }
            }
            for (const r of rectangles) {
                const corners = [{x:r.x, y:r.y, corner:'topLeft'}, {x:r.x+r.width, y:r.y, corner:'topRight'}, {x:r.x, y:r.y+r.height, corner:'bottomLeft'}, {x:r.x+r.width, y:r.y+r.height, corner:'bottomRight'}];
                for (const corner of corners) {
                    if (getDistance({x, y}, corner) < HOVER_TOLERANCE / scale) return { type: 'point', shapeType: 'rectangle', shapeId: r.id, corner: corner.corner };
                }
            }
            for (const c of circles) {
                if (getDistance({x, y}, {x: c.x, y: c.y}) < HOVER_TOLERANCE / scale) return { type: 'circle_center', shapeType: 'circle', shapeId: c.id };
            }
            // --- NEW --- Add detection for arc points
            for (const a of arcs) {
                const startPoint = { x: a.cx + a.radius * Math.cos(a.startAngle), y: a.cy + a.radius * Math.sin(a.startAngle) };
                if (getDistance({x, y}, startPoint) < HOVER_TOLERANCE / scale) return { type: 'point', shapeType: 'arc', shapeId: a.id, pointType: 'start' };
                
                const endPoint = { x: a.cx + a.radius * Math.cos(a.endAngle), y: a.cy + a.radius * Math.sin(a.endAngle) };
                if (getDistance({x, y}, endPoint) < HOVER_TOLERANCE / scale) return { type: 'point', shapeType: 'arc', shapeId: a.id, pointType: 'end' };

                if (getDistance({x, y}, {x: a.cx, y: a.cy}) < HOVER_TOLERANCE / scale) return { type: 'arc_center', shapeType: 'arc', shapeId: a.id };
            }

            // Priority 2: Edges and Contours
            const polylineSegment = getPolylineSegmentAt(x, y);
            if (polylineSegment) return { type: 'edge', shapeType: 'polygon', shapeId: polylineSegment.polygonId, lineIndex: polylineSegment.lineIndex };
            
            const rectangleSide = getRectangleSideAt(x, y);
            if (rectangleSide) return { type: 'edge', shapeType: 'rectangle', shapeId: rectangleSide.rectangleId, side: rectangleSide.side };

            const circleContour = isMouseOverCircle(x, y);
            if (circleContour) return { type: 'circle_contour', shapeType: 'circle', shapeId: circleContour.id };

            const arcContour = isMouseOverArc(x, y);
            if (arcContour) return { type: 'arc_contour', shapeType: 'arc', shapeId: arcContour.id };

            const ellipseContour = isMouseOverEllipse(x, y);
            if (ellipseContour) return { type: 'ellipse_contour', shapeType: 'ellipse', shapeId: ellipseContour.id };

            return null;
        }

        // ===============================================
        // Deletion Logic
        // ===============================================
        
        function deleteElement(element) {
            if (!element) return;
            switch(element.type) {
                case 'polygon': polygons = polygons.filter(p => p.id !== element.id); break;
                case 'circle': circles = circles.filter(c => c.id !== element.id); break;
                case 'rectangle': rectangles = rectangles.filter(r => r.id !== element.id); break;
                case 'dimension': dimensions = dimensions.filter(d => d.id !== element.id); break;
                case 'arc': arcs = arcs.filter(a => a.id !== element.id); break;
                case 'ellipse': ellipses = ellipses.filter(e => e.id !== element.id); break;
                case 'spline': splines = splines.filter(s => s.id !== element.id); break;
            }
            selectedElement = null;
            saveState();
            draw();
        }

        // ===============================================
        // Dimensioning Logic
        // ===============================================

        function resetDimensionCreation() {
            dimensionCreationStep = 0;
            firstElementForDimension = null;
            secondElementForDimension = null;
            tempDimension = null;
            draw();
        }

        function finalizeDimension() {
            if (tempDimension) {
                tempDimension.id = dimensionIdCounter++;
                dimensions.push(JSON.parse(JSON.stringify(tempDimension)));
                saveState();
            }
            resetDimensionCreation();
        }

        function createTempDimensionFromElements(el1, el2, mouseX, mouseY) {
            if (!el2) { // Single element dimension
                if (el1.type === 'edge') {
                    return { dimensionType: 'line', element1: el1, offset: DIMENSION_OFFSET };
                } else if (el1.type === 'circle_contour') {
                    const circle = findShapeById(el1.shapeId, 'circle');
                    return {
                        dimensionType: 'diameter',
                        element1: el1,
                        angle: Math.atan2(mouseY - circle.y, mouseX - circle.x)
                    };
                } else if (el1.type === 'arc_contour') {
                    const arc = findShapeById(el1.shapeId, 'arc');
                    return {
                        dimensionType: 'radius',
                        element1: el1,
                        angle: Math.atan2(mouseY - arc.cy, mouseX - arc.cx)
                    };
                } else if (el1.type === 'ellipse_contour') {
                    const ellipse = findShapeById(el1.shapeId, 'ellipse');
                    const angle = Math.atan2(mouseY - ellipse.y, mouseX - ellipse.x);
                    const absCos = Math.abs(Math.cos(angle));
                    const absSin = Math.abs(Math.sin(angle));
                    if (absCos > absSin) { // More horizontal click
                        return { dimensionType: 'ellipse_radiusX', element1: el1, offset: DIMENSION_OFFSET };
                    } else { // More vertical click
                        return { dimensionType: 'ellipse_radiusY', element1: el1, offset: DIMENSION_OFFSET };
                    }
                }
            } else { // Two element dimension
                const firstIsPoint = el1.type === 'point' || el1.type === 'circle_center';
                const secondIsPoint = el2.type === 'point' || el2.type === 'circle_center';
                if (firstIsPoint && secondIsPoint) {
                    return { dimensionType: 'aligned', element1: el1, element2: el2, offset: DIMENSION_OFFSET };
                }
                const firstIsEdge = el1.type === 'edge';
                const secondIsEdge = el2.type === 'edge';
                if (firstIsEdge && secondIsEdge) {
                    return { dimensionType: 'angle', element1: el1, element2: el2, offset: DIMENSION_OFFSET * 2 };
                }
            }
            return null;
        }
        
        function getLineFromElementInfo(elementInfo) {
            if (!elementInfo || elementInfo.type !== 'edge') return null;
            const shape = findShapeById(elementInfo.shapeId, elementInfo.shapeType);
            if (!shape) return null;

            if (elementInfo.shapeType === 'polygon') {
                return shape.lines[elementInfo.lineIndex];
            } else if (elementInfo.shapeType === 'rectangle') {
                const r = shape;
                const sides = [
                    { name: 'top', x1: r.x, y1: r.y, x2: r.x + r.width, y2: r.y },
                    { name: 'right', x1: r.x + r.width, y1: r.y, x2: r.x + r.width, y2: r.y + r.height },
                    { name: 'bottom', x1: r.x + r.width, y1: r.y + r.height, x2: r.x, y2: r.y + r.height },
                    { name: 'left', x1: r.x, y1: r.y + r.height, x2: r.x, y2: r.y }
                ];
                return sides.find(s => s.name === elementInfo.side);
            }
            return null;
        }

        function findLineIntersection(line1, line2, onSegment = true) {
            if (!line1 || !line2) return null;
            const { x1, y1, x2, y2 } = line1;
            const { x1: x3, y1: y3, x2: x4, y2: y4 } = line2;

            const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (den === 0) return null; // Parallel or collinear

            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
            
            const intersectionPoint = { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };

            if (onSegment) {
                if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                    return intersectionPoint;
                }
                return null;
            }

            return intersectionPoint;
        }

        function updateTempDimension(mouseX, mouseY) {
            if (!tempDimension) return;

            if (tempDimension.element2) { // Two-element dimensions
                if (tempDimension.dimensionType === 'angle') {
                    const line1 = getLineFromElementInfo(tempDimension.element1);
                    const line2 = getLineFromElementInfo(tempDimension.element2);
                    const intersection = findLineIntersection(line1, line2, false);

                    if (intersection) {
                        tempDimension.offset = getDistance({ x: mouseX, y: mouseY }, intersection);

                        // Determine if the mouse is in the reflex angle sector
                        const p1_start = {x: line1.x1, y: line1.y1};
                        const p1_end = {x: line1.x2, y: line1.y2};
                        const p2_start = {x: line2.x1, y: line2.y1};
                        const p2_end = {x: line2.x2, y: line2.y2};

                        const v1_vec = getDistance(intersection, p1_start) > getDistance(intersection, p1_end) ? {x: p1_start.x - intersection.x, y: p1_start.y - intersection.y} : {x: p1_end.x - intersection.x, y: p1_end.y - intersection.y};
                        const v2_vec = getDistance(intersection, p2_start) > getDistance(intersection, p2_end) ? {x: p2_start.x - intersection.x, y: p2_start.y - intersection.y} : {x: p2_end.x - intersection.x, y: p2_end.y - intersection.y};
                        const mouse_vec = {x: mouseX - intersection.x, y: mouseY - intersection.y};

                        const cross_v1_mouse = v1_vec.x * mouse_vec.y - v1_vec.y * mouse_vec.x;
                        const cross_mouse_v2 = mouse_vec.x * v2_vec.y - mouse_vec.y * v2_vec.x;
                        const cross_v1_v2 = v1_vec.x * v2_vec.y - v1_vec.y * v2_vec.x;

                        if (cross_v1_v2 > 0) { // v2 is counter-clockwise from v1
                            tempDimension.isReflex = !(cross_v1_mouse > 0 && cross_mouse_v2 > 0);
                        } else { // v1 is counter-clockwise from v2
                            tempDimension.isReflex = !(cross_v1_mouse < 0 && cross_mouse_v2 < 0);
                        }
                    }
                } else { // Point-to-point (horizontal, vertical, aligned)
                    const p1 = getPointFromElementInfo(tempDimension.element1);
                    const p2 = getPointFromElementInfo(tempDimension.element2);
                    if (!p1 || !p2) return;

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;
                    
                    const angleToMouse = Math.atan2(mouseY - midY, mouseX - midX);
                    const lineAngle = Math.atan2(dy, dx);
                    let angleDiff = Math.abs(normalizeAngle(angleToMouse - lineAngle));
                    
                    const deadZone = Math.PI / 6; 
                    if (angleDiff > Math.PI / 2 - deadZone && angleDiff < Math.PI / 2 + deadZone) {
                        tempDimension.dimensionType = 'aligned';
                    } else {
                        const mouseVec = { x: mouseX - midX, y: mouseY - midY };
                        const lineVec = { x: dx, y: dy };
                        
                        if (Math.abs(lineVec.x) > Math.abs(lineVec.y)) { // More horizontal line
                             tempDimension.dimensionType = (Math.abs(mouseVec.y) > Math.abs(mouseVec.x)) ? 'vertical' : 'horizontal';
                        } else { // More vertical line
                             tempDimension.dimensionType = (Math.abs(mouseVec.x) > Math.abs(mouseVec.y)) ? 'horizontal' : 'vertical';
                        }
                    }

                    if (tempDimension.dimensionType === 'aligned') {
                        const perpAngle = lineAngle + Math.PI / 2;
                        tempDimension.offset = (mouseX - p1.x) * Math.cos(perpAngle) + (mouseY - p1.y) * Math.sin(perpAngle);
                    } else if (tempDimension.dimensionType === 'horizontal') {
                        tempDimension.offset = mouseY - p1.y;
                    } else if (tempDimension.dimensionType === 'vertical') {
                        tempDimension.offset = mouseX - p1.x;
                    }
                }
            } else { // Single-element dimensions
                if (tempDimension.dimensionType === 'line') {
                    const line = getLineFromElementInfo(tempDimension.element1);
                    if (!line) return;
                    const angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1) + Math.PI / 2;
                    tempDimension.offset = (mouseX - line.x1) * Math.cos(angle) + (mouseY - line.y1) * Math.sin(angle);
                } else if (tempDimension.dimensionType === 'diameter') {
                    const circle = findShapeById(tempDimension.element1.shapeId, 'circle');
                    if (circle) tempDimension.angle = Math.atan2(mouseY - circle.y, mouseX - circle.x);
                }
                 else if (tempDimension.dimensionType === 'radius') {
                    const arc = findShapeById(tempDimension.element1.shapeId, 'arc');
                    if (arc) tempDimension.angle = Math.atan2(mouseY - arc.cy, mouseX - arc.cx);
                }
            }
        }


        // ===============================================
        // Event Handlers for Mouse and Touch
        // ===============================================

        function handlePointerDown(e) {
            e.preventDefault();
            const { x, y } = getCanvasCoordinates(e);

            if (e.button === 1) { // Middle click for panning
                isPanning = true;
                lastPointerX = e.clientX;
                lastPointerY = e.clientY;
                canvas.style.cursor = 'grabbing';
                selectedElement = null;
                return;
            }

            if (e.button === 0 || e.type === 'touchstart') {
                let startX = snapPoint ? snapPoint.x : (isSnapEnabled ? snapToGrid(x) : x);
                let startY = snapPoint ? snapPoint.y : (isSnapEnabled ? snapToGrid(y) : y);

                if (currentTool === 'line') {
                    if (!currentPolygonLines) {
                        currentPolygonLines = [{ x1: startX, y1: startY, x2: startX, y2: startY }];
                    } else {
                        const lastLine = currentPolygonLines[currentPolygonLines.length - 1];
                        currentPolygonLines.push({ x1: lastLine.x2, y1: lastLine.y2, x2: startX, y2: startY });
                    }
                } else if (currentTool === 'rectangle') {
                    tempShape = { type: 'rectangle', x: startX, y: startY, width: 0, height: 0, startX: startX, startY: startY };
                } else if (currentTool === 'circle') {
                    tempShape = { type: 'circle', x: startX, y: startY, radius: 0 };
                } else if (currentTool === 'arc') {
                    // --- MODIFIED --- New 3-point arc logic
                    if (!tempShape) { // First click: define start point
                        tempShape = { type: 'arc', step: 1, p1: { x: startX, y: startY }, mousePos: {x,y} };
                    } else if (tempShape.step === 1) { // Second click: define end point
                        tempShape.step = 2;
                        tempShape.p2 = { x: startX, y: startY };
                    } else if (tempShape.step === 2) { // Third click: define curvature
                        const p3 = { x: startX, y: startY };
                        const arcParams = calculateArcFromThreePoints(tempShape.p1, tempShape.p2, p3);
                        if (arcParams) {
                            arcs.push({
                                id: arcIdCounter++, type: 'arc',
                                // --- NEW --- Store defining points for parametric updates
                                p1: { ...tempShape.p1 }, 
                                p2: { ...tempShape.p2 },
                                p3: { ...p3 },
                                cx: arcParams.x, cy: arcParams.y, radius: arcParams.radius,
                                startAngle: arcParams.startAngle, endAngle: arcParams.endAngle,
                                anticlockwise: arcParams.anticlockwise,
                                color: 'rgb(34, 197, 94)', lineWidth: 2, lineType: 'solid'
                            });
                        } else {
                            // If points are collinear, draw a line instead.
                            polygons.push({
                                id: polygonIdCounter++, isClosed: false, type: 'polygon',
                                lines: [{ x1: tempShape.p1.x, y1: tempShape.p1.y, x2: tempShape.p2.x, y2: tempShape.p2.y, type: 'line' }],
                                color: 'rgb(34, 197, 94)', lineWidth: 2, lineType: 'solid'
                            });
                        }
                        saveState();
                        tempShape = null; // Reset after creation
                    }
                } else if (currentTool === 'ellipse') {
                    tempShape = { type: 'ellipse', x: startX, y: startY, radiusX: 0, radiusY: 0 };
                } else if (currentTool === 'spline') {
                    if (!currentSplinePoints) {
                        currentSplinePoints = [{ x: startX, y: startY }];
                    }
                    currentSplinePoints.push({ x: startX, y: startY });
                } else if (currentTool === 'dimension') {
                    const clickedElement = getGeometricElementAt(x, y);

                    if (dimensionCreationStep === 0) {
                        if (clickedElement) {
                            firstElementForDimension = clickedElement;
                            dimensionCreationStep = 1;
                            tempDimension = createTempDimensionFromElements(firstElementForDimension, null, x, y);
                        }
                    } else if (dimensionCreationStep === 1) {
                        if (clickedElement) {
                            const firstIsPoint = firstElementForDimension.type === 'point' || firstElementForDimension.type === 'circle_center';
                            const secondIsPoint = clickedElement.type === 'point' || clickedElement.type === 'circle_center';
                            const firstIsEdge = firstElementForDimension.type === 'edge';
                            const secondIsEdge = clickedElement.type === 'edge';

                            if (firstIsPoint && secondIsPoint) {
                                secondElementForDimension = clickedElement;
                                tempDimension = createTempDimensionFromElements(firstElementForDimension, secondElementForDimension, x, y);
                                dimensionCreationStep = 2;
                            } else if (firstIsEdge && secondIsEdge) {
                                secondElementForDimension = clickedElement;
                                tempDimension = createTempDimensionFromElements(firstElementForDimension, secondElementForDimension, x, y);
                                dimensionCreationStep = 2;
                            } else {
                                finalizeDimension();
                            }
                        } else {
                            finalizeDimension();
                        }
                    } else if (dimensionCreationStep === 2) {
                        finalizeDimension();
                    }
                } else if (currentTool === 'coincidentConstraint') {
                    const clickedElement = getGeometricElementAt(x, y);
                    if (clickedElement) {
                        if (constraintCreationStep === 0) {
                            firstElementForConstraint = clickedElement;
                            constraintCreationStep = 1;
                        } else {
                            constraints.push({
                                id: constraintIdCounter++,
                                type: 'coincident',
                                element1: firstElementForConstraint, 
                                element2: clickedElement
                            });
                            resetConstraintCreation();
                            applyConstraints();
                            saveState();
                            draw();
                        }
                    }
                    return;
                } else if (currentTool === 'tangentConstraint') {
                    const clickedElement = getGeometricElementAt(x, y);
                    if (clickedElement && (clickedElement.type === 'edge' || clickedElement.type === 'circle_contour')) {
                        if (constraintCreationStep === 0) {
                            firstElementForConstraint = clickedElement;
                            constraintCreationStep = 1;
                        } else {
                            const isFirstCircle = firstElementForConstraint.type === 'circle_contour';
                            const isSecondCircle = clickedElement.type === 'circle_contour';
                            if ((isFirstCircle && !isSecondCircle) || (!isFirstCircle && isSecondCircle) || (isFirstCircle && isSecondCircle)) {
                                constraints.push({
                                    id: constraintIdCounter++,
                                    type: 'tangent',
                                    element1: firstElementForConstraint,
                                    element2: clickedElement
                                });
                                resetConstraintCreation();
                                applyConstraints();
                                saveState();
                                draw();
                            } else {
                                resetConstraintCreation();
                            }
                        }
                    }
                } else if (currentTool === 'horizontalConstraint' || currentTool === 'verticalConstraint') {
                    const clickedElement = getGeometricElementAt(x, y);
                     if (constraintCreationStep === 0) {
                        if (clickedElement) {
                            // If the first click is on a line, apply the old single-line constraint
                            if (clickedElement.type === 'edge') {
                                constraints.push({
                                    id: constraintIdCounter++,
                                    type: currentTool.replace('Constraint', ''), // 'horizontal' or 'vertical'
                                    element1: clickedElement
                                });
                                resetConstraintCreation();
                                applyConstraints();
                                saveState();
                                draw();
                            } else if (clickedElement.type === 'point' || clickedElement.type === 'circle_center') {
                                // If the first click is a point, start multi-point alignment
                                firstElementForConstraint = clickedElement;
                                constraintCreationStep = 1;
                            }
                        }
                    } else { // constraintCreationStep === 1
                        if (clickedElement && (clickedElement.type === 'point' || clickedElement.type === 'circle_center')) {
                            const newConstraintType = currentTool === 'horizontalConstraint' ? 'alignHorizontal' : 'alignVertical';
                            constraints.push({
                                id: constraintIdCounter++,
                                type: newConstraintType,
                                element1: firstElementForConstraint,
                                element2: clickedElement
                            });
                            resetConstraintCreation();
                            applyConstraints();
                            saveState();
                            draw();
                        } else {
                            // Clicked on empty space or an invalid element, so cancel the operation
                            resetConstraintCreation();
                        }
                    }
                } else if (currentTool === 'parallelConstraint' || currentTool === 'perpendicularConstraint' || currentTool === 'collinearConstraint') {
                    const clickedElement = getGeometricElementAt(x, y);
                    if (clickedElement && clickedElement.type === 'edge') {
                        if (constraintCreationStep === 0) {
                            firstElementForConstraint = clickedElement;
                            constraintCreationStep = 1;
                        } else {
                            const newConstraintType = currentTool.replace('Constraint', ''); // parallel, perpendicular, collinear
                            constraints.push({
                                id: constraintIdCounter++,
                                type: newConstraintType,
                                element1: firstElementForConstraint,
                                element2: clickedElement
                            });
                            resetConstraintCreation();
                            applyConstraints();
                            saveState();
                            draw();
                        }
                    }
                } else if (currentTool === 'fixConstraint') {
                    const clickedElement = getGeometricElementAt(x, y);
                    if (clickedElement && (clickedElement.type === 'point' || clickedElement.type === 'circle_center')) {
                        const point = getPointFromElementInfo(clickedElement);
                        if (point) {
                            constraints.push({
                                id: constraintIdCounter++,
                                type: 'fix',
                                element1: clickedElement,
                                x: point.x,
                                y: point.y
                            });
                            resetConstraintCreation();
                            applyConstraints();
                            saveState();
                            draw();
                        }
                    }
                } else if (currentTool === 'trim') {
                    const element = getGeometricElementAt(x, y);
                    if (element && element.type === 'edge') {
                        performSmartTrim(element, x, y);
                    }
                } else if (currentTool === 'offset') {
                    const shapeInfo = findShapeAt(x, y);
                    if (shapeInfo && (shapeInfo.type === 'rectangle' || shapeInfo.type === 'circle' || shapeInfo.type === 'polygon')) {
                        firstElementForModifier = findShapeById(shapeInfo.id, shapeInfo.type);
                        modifierModalTitle.textContent = 'Offset Distance';
                        modifierLabel.textContent = 'Distance (mm)';
                        chamferOptions.style.display = 'none';
                        offsetOptions.style.display = 'block';
                        modifierModal.style.display = 'flex';
                        modifierValueInput.focus();
                    }
                } else if (currentTool === 'fillet' || currentTool === 'chamfer') {
                    const element = getGeometricElementAt(x, y);
                    if (element && element.type === 'edge') {
                        if (modifierStep === 0) {
                            firstElementForModifier = element;
                            modifierStep = 1;
                        } else {
                            if (firstElementForModifier.shapeId === element.shapeId) {
                                if (element.shapeType === 'rectangle') {
                                    const rect = findShapeById(element.shapeId, 'rectangle');
                                    if (!rect) { resetModifier(); return; }

                                    const newPolygonLines = [
                                        { x1: rect.x, y1: rect.y, x2: rect.x + rect.width, y2: rect.y },
                                        { x1: rect.x + rect.width, y1: rect.y, x2: rect.x + rect.width, y2: rect.y + rect.height },
                                        { x1: rect.x + rect.width, y1: rect.y + rect.height, x2: rect.x, y2: rect.y + rect.height },
                                        { x1: rect.x, y1: rect.y + rect.height, x2: rect.x, y2: rect.y }
                                    ];

                                    const polygon = {
                                        id: polygonIdCounter++, isClosed: true, type: 'polygon', lines: newPolygonLines,
                                        color: rect.color, lineWidth: rect.lineWidth, lineType: rect.lineType
                                    };
                                    polygons.push(polygon);
                                    rectangles = rectangles.filter(r => r.id !== rect.id);
                                    
                                    const sideMap = { top: 0, right: 1, bottom: 2, left: 3 };
                                    firstElementForModifier = { type: 'edge', shapeType: 'polygon', shapeId: polygon.id, lineIndex: sideMap[firstElementForModifier.side] };
                                    secondElementForModifier = { type: 'edge', shapeType: 'polygon', shapeId: polygon.id, lineIndex: sideMap[element.side] };
                                } else {
                                    secondElementForModifier = element;
                                }

                                modifierModalTitle.textContent = currentTool === 'fillet' ? 'Fillet Radius' : 'Chamfer Distance';
                                modifierLabel.textContent = currentTool === 'fillet' ? 'Radius (mm)' : 'Distance (mm)';
                                offsetOptions.style.display = 'none';
                                chamferOptions.style.display = currentTool === 'chamfer' ? 'block' : 'none';
                                modifierModal.style.display = 'flex';
                                modifierValueInput.focus();
                            } else {
                                resetModifier();
                            }
                        }
                    }
                } else { // Select/Move tool is active
                    const clickedElement = getGeometricElementAt(x, y); // Use the more detailed detector
                    selectedElement = clickedElement; // This can be a shape OR a point
                    if (!selectedElement) { // If nothing specific clicked, try for a whole shape
                        selectedElement = findShapeAt(x, y);
                    }
                    
                    if (selectedElement) {
                        isDraggingShape = true; // Use a single flag for dragging anything
                        dragStartCoords = { x, y };
                    }
                    draw();
                }
            }
        }
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('touchstart', handlePointerDown);

        function handlePointerMove(e) {
            e.preventDefault();
            const { x, y } = getCanvasCoordinates(e);

            if (!isPanning) {
                snapPoint = findSnapPoint(x, y);
            } else {
                snapPoint = null;
            }

            let currentX = snapPoint ? snapPoint.x : x;
            let currentY = snapPoint ? snapPoint.y : y;

            if (isPanning) {
                const dx = e.clientX - lastPointerX;
                const dy = e.clientY - lastPointerY;
                offsetX += dx / scale;
                offsetY += dy / scale;
                lastPointerX = e.clientX;
                lastPointerY = e.clientY;
            } else if (isDraggingShape && selectedElement) {
                const dx = x - dragStartCoords.x;
                const dy = y - dragStartCoords.y;
                const shape = findShapeById(selectedElement.id, selectedElement.type);
                if (shape) {
                    if (shape.type === 'polygon') {
                        shape.lines.forEach(line => {
                             if(line.type === 'arc') {
                                line.cx += dx; line.cy += dy;
                            } else {
                                line.x1 += dx; line.y1 += dy;
                                line.x2 += dx; line.y2 += dy;
                            }
                        });
                    } else if (shape.type === 'spline') {
                        shape.points.forEach(p => {
                            p.x += dx;
                            p.y += dy;
                        });
                    } else { // Circle, Rectangle, Arc, Ellipse
                        const centerPropX = shape.type === 'arc' ? 'cx' : 'x';
                        const centerPropY = shape.type === 'arc' ? 'cy' : 'y';
                        shape[centerPropX] += dx;
                        shape[centerPropY] += dy;
                    }
                }
                dragStartCoords = { x, y };
                applyConstraints(); // Re-apply constraints during drag
            } else if (currentTool === 'line' && currentPolygonLines) {
                const lastLine = currentPolygonLines[currentPolygonLines.length - 1];
                lastLine.x2 = currentX;
                lastLine.y2 = currentY;
            } else if (currentTool === 'spline' && currentSplinePoints) {
                currentSplinePoints[currentSplinePoints.length - 1] = { x: currentX, y: currentY };
            } else if (tempShape) {
                if (tempShape.type === 'circle') tempShape.radius = getDistance({x:tempShape.x, y:tempShape.y}, {x:currentX, y:currentY});
                else if (tempShape.type === 'rectangle') { 
                    tempShape.width = currentX - tempShape.startX; 
                    tempShape.height = currentY - tempShape.startY; 
                } else if (tempShape.type === 'ellipse') {
                    tempShape.radiusX = Math.abs(currentX - tempShape.x);
                    tempShape.radiusY = Math.abs(currentY - tempShape.y);
                } else if (tempShape.type === 'arc') {
                    tempShape.mousePos = { x, y }; // Use raw coordinates for smooth preview
                }
            } else if (currentTool === 'dimension' && tempDimension) {
                updateTempDimension(x, y);
            } else {
                hoveredElement = findShapeAt(x, y);
                canvas.style.cursor = hoveredElement ? 'pointer' : 'default';
            }
            draw();
        }
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('touchmove', handlePointerMove);

        function handlePointerUp(e) {
            e.preventDefault();
            isPanning = false;
            if (isDraggingShape) {
                isDraggingShape = false;
                saveState();
            }
            
            if (e.button === 0) {
                if (tempShape) {
                    if (tempShape.type === 'rectangle' && (Math.abs(tempShape.width) > 1 || Math.abs(tempShape.height) > 1)) {
                        rectangles.push({ 
                            id: rectangleIdCounter++, type: 'rectangle', 
                            x: tempShape.width < 0 ? tempShape.startX + tempShape.width : tempShape.startX,
                            y: tempShape.height < 0 ? tempShape.startY + tempShape.height : tempShape.startY,
                            width: Math.abs(tempShape.width), height: Math.abs(tempShape.height),
                            color: 'rgb(34, 197, 94)', lineWidth: 2, lineType: 'solid'
                        });
                        saveState();
                    } else if (tempShape.type === 'circle' && tempShape.radius > 1) {
                        circles.push({ 
                            id: circleIdCounter++, type: 'circle', 
                            x: tempShape.x, y: tempShape.y, radius: tempShape.radius,
                            color: 'rgb(34, 197, 94)', lineWidth: 2, lineType: 'solid'
                        });
                        saveState();
                    } else if (tempShape.type === 'ellipse' && (tempShape.radiusX > 1 || tempShape.radiusY > 1)) {
                        ellipses.push({
                            id: ellipseIdCounter++, type: 'ellipse',
                            x: tempShape.x, y: tempShape.y,
                            radiusX: tempShape.radiusX, radiusY: tempShape.radiusY,
                            color: 'rgb(34, 197, 94)', lineWidth: 2, lineType: 'solid'
                        });
                        saveState();
                    }

                    if (tempShape.type !== 'arc') { // Arc is finalized on 3rd click, not mouseup
                        tempShape = null;
                    }
                }
            }
            draw();
        }
        canvas.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('touchend', handlePointerUp);
        
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            
            if (currentTool === 'dimension') {
                resetDimensionCreation();
            }
            if (currentTool && (currentTool.includes('Constraint') || ['trim', 'offset', 'fillet', 'chamfer'].includes(currentTool))) {
                resetConstraintCreation();
                resetModifier();
            }

            const shapeAtCursor = findShapeAt(getCanvasCoordinates(e).x, getCanvasCoordinates(e).y);
            const isDrawingLine = currentTool === 'line' && currentPolygonLines && currentPolygonLines.length > 0;
            const isDrawingSpline = currentTool === 'spline' && currentSplinePoints && currentSplinePoints.length > 0;

            if (currentTool === null && shapeAtCursor) {
                lastRightClickedElement = shapeAtCursor;
                deleteMenuItem.style.display = 'block';
                endLinesMenuItem.style.display = 'none';
                customContextMenu.style.left = `${e.clientX}px`;
                customContextMenu.style.top = `${e.clientY}px`;
                customContextMenu.style.display = 'block';
            } else if(isDrawingLine || isDrawingSpline){
                endLinesMenuItem.style.display = 'block';
                deleteMenuItem.style.display = 'none';
                customContextMenu.style.left = `${e.clientX}px`;
                customContextMenu.style.top = `${e.clientY}px`;
                customContextMenu.style.display = 'block';
            }
        });

        endLinesMenuItem.addEventListener('click', () => {
             if (currentTool === 'line' && currentPolygonLines && currentPolygonLines.length > 0) {
                currentPolygonLines.pop(); 
                
                if (currentPolygonLines.length > 0) {
                    polygons.push({ 
                        id: polygonIdCounter++, 
                        isClosed: false, 
                        type: 'polygon', 
                        lines: JSON.parse(JSON.stringify(currentPolygonLines)),
                        color: 'rgb(34, 197, 94)', lineWidth: 2, lineType: 'solid'
                    });
                    saveState();
                }
                currentPolygonLines = null;
            } else if (currentTool === 'spline' && currentSplinePoints && currentSplinePoints.length > 1) {
                currentSplinePoints.pop();
                splines.push({
                    id: splineIdCounter++, type: 'spline',
                    points: JSON.parse(JSON.stringify(currentSplinePoints)),
                    color: 'rgb(34, 197, 94)', lineWidth: 2, lineType: 'solid'
                });
                saveState();
                currentSplinePoints = null;
            }
            
            customContextMenu.style.display = 'none';
            draw();
        });

        deleteMenuItem.addEventListener('click', () => {
            if (lastRightClickedElement) {
                deleteElement(lastRightClickedElement);
                lastRightClickedElement = null;
            }
            customContextMenu.style.display = 'none';
        });

        window.addEventListener('click', (e) => {
            if (!drawToolsButton.contains(e.target)) {
                drawToolsDropdown.style.display = 'none';
            }
            if (!constraintToolsButton.contains(e.target)) {
                constraintToolsDropdown.style.display = 'none';
            }
            if (!modifyToolsButton.contains(e.target)) {
                modifyToolsDropdown.style.display = 'none';
            }
            if (!customContextMenu.contains(e.target)) {
                 customContextMenu.style.display = 'none';
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const mouseX_screen = e.clientX - rect.left;
            const mouseY_screen = e.clientY - rect.top;

            // World coordinates before zoom
            const worldX_before = (mouseX_screen / scale) - offsetX;
            const worldY_before = (mouseY_screen / scale) - offsetY;

            // Calculate new scale
            const scaleFactor = 1 - e.deltaY * ZOOM_SENSITIVITY;
            const newScale = Math.min(Math.max(0.1, scale * scaleFactor), 20);

            // Calculate new offset to keep the world point under the mouse constant
            // After zoom, the world point should be at the same screen location.
            // worldX_before = (mouseX_screen / newScale) - newOffsetX
            // So, newOffsetX = (mouseX_screen / newScale) - worldX_before
            offsetX = (mouseX_screen / newScale) - worldX_before;
            offsetY = (mouseY_screen / newScale) - worldY_before;
            
            scale = newScale;

            draw();
        });

        canvas.addEventListener('dblclick', (e) => {
            if (currentTool !== null) return;
            const { x, y } = getCanvasCoordinates(e);
            
            const clickedDimension = isMouseOverDimension(x, y);
            if (clickedDimension) {
                editingDimension = clickedDimension;
                const dimData = getDimensionDrawingData(clickedDimension);
                if (dimData) {
                    if (dimData.type === 'angle') {
                        dimensionLabel.textContent = 'New Value (deg or expression)';
                        dimensionValueInput.value = (dimData.value * 180 / Math.PI).toFixed(2);
                    } else {
                        dimensionLabel.textContent = 'New Value (mm or expression)';
                        dimensionValueInput.value = pixelsToMm(dimData.value).toFixed(2);
                    }
                    editDimensionModal.style.display = 'flex';
                    dimensionValueInput.focus();
                    dimensionValueInput.select();
                }
                return; // Prioritize dimensions
            }

            const clickedShapeInfo = findShapeAt(x, y);
            if(clickedShapeInfo && clickedShapeInfo.type !== 'dimension') {
                editingShape = findShapeById(clickedShapeInfo.id, clickedShapeInfo.type);
                if (editingShape) {
                    lineColorInput.value = editingShape.color || '#22c55e'; // Default to green if no color
                    lineWidthInput.value = editingShape.lineWidth || 2;
                    lineTypeSelect.value = editingShape.lineType || 'solid';
                    shapeInspectorPanel.style.display = 'block';
                    // --- FIX: Focus an input in the inspector panel when it opens ---
                    lineWidthInput.focus();
                    lineWidthInput.select();
                }
            }
        });
        
        // --- Global shortcuts ---
        window.addEventListener('keydown', (e) => {
            // Do not trigger global shortcuts if a modal input is focused
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') {
                return;
            }

            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedElement) {
                    deleteElement(selectedElement);
                }
            } else if (e.key === 'Escape') {
                // General "cancel" action for ongoing operations
                if (currentTool === 'dimension') {
                    resetDimensionCreation();
                }
                if (currentTool && (currentTool.includes('Constraint') || ['trim', 'offset', 'fillet', 'chamfer'].includes(currentTool))) {
                    resetConstraintCreation();
                    resetModifier();
                }
                 currentPolygonLines = null;
                 currentSplinePoints = null;
                 tempShape = null;
                 selectedElement = null; // Also deselect elements
                 draw();
            }
        });

        // --- NEW: Modal-specific keydown listeners for reliability ---
        editDimensionModal.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                okEditButton.click();
            } else if (e.key === 'Escape') {
                cancelEditButton.click();
            }
        });

        shapeInspectorPanel.addEventListener('keydown', (e) => {
             if (e.key === 'Enter') {
                inspectorOkButton.click();
            } else if (e.key === 'Escape') {
                inspectorCancelButton.click();
            }
        });

        modifierModal.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                okModifierButton.click();
            } else if (e.key === 'Escape') {
                cancelModifierButton.click();
            }
        });


        // ===============================================
        // Button Listeners (Tools, Undo/Redo, etc.)
        // ===============================================

        const allToolButtons = document.querySelectorAll('#topBar button');
        const toolButtons = [selectTool, lineTool, rectangleTool, circleTool, arcTool, ellipseTool, splineTool, dimensionTool, coincidentConstraintTool, tangentConstraintTool, fixConstraintTool, horizontalConstraintTool, verticalConstraintTool, parallelConstraintTool, perpendicularConstraintTool, collinearConstraintTool, trimTool, offsetTool, filletTool, chamferTool];

        function setActiveTool(button) {
            allToolButtons.forEach(btn => {
                btn.classList.remove('active-tool');
                btn.classList.add('bg-gray-200', 'text-gray-800');
                btn.classList.remove('bg-indigo-500', 'text-white');
            });

            const parentDropdown = button.closest('.dropdown-content');
            
            if (parentDropdown) {
                 const mainButton = parentDropdown.previousElementSibling;
                 mainButton.classList.add('active-tool');
                 mainButton.classList.remove('bg-gray-200', 'text-gray-800');
                 mainButton.classList.add('bg-indigo-500', 'text-white');
            } else {
                 button.classList.add('active-tool');
                 button.classList.remove('bg-gray-200', 'text-gray-800');
                 button.classList.add('bg-indigo-500', 'text-white');
            }


            const newTool = button.id.replace('Tool', '');
            currentTool = newTool === 'select' ? null : newTool;
            
            // Update dropdown icons
            if (drawToolsDropdown.contains(button)) {
                activeDrawToolIcon.innerHTML = button.innerHTML;
            } else if (constraintToolsDropdown.contains(button)) {
                activeConstraintToolIcon.innerHTML = button.innerHTML;
            } else if (modifyToolsDropdown.contains(button)) {
                activeModifyToolIcon.innerHTML = button.innerHTML;
            }
            
            drawToolsDropdown.style.display = 'none';
            constraintToolsDropdown.style.display = 'none';
            modifyToolsDropdown.style.display = 'none';

            resetConstraintCreation();
            resetDimensionCreation();
            resetModifier();
            selectedElement = null;
            draw();
        }

        toolButtons.forEach(button => {
            button.addEventListener('click', () => setActiveTool(button));
        });

        drawToolsButton.addEventListener('click', () => {
            constraintToolsDropdown.style.display = 'none';
            modifyToolsDropdown.style.display = 'none';
            drawToolsDropdown.style.display = drawToolsDropdown.style.display === 'block' ? 'none' : 'block';
        });

        constraintToolsButton.addEventListener('click', () => {
            drawToolsDropdown.style.display = 'none';
            modifyToolsDropdown.style.display = 'none';
            constraintToolsDropdown.style.display = constraintToolsDropdown.style.display === 'block' ? 'none' : 'block';
        });

        modifyToolsButton.addEventListener('click', () => {
            drawToolsDropdown.style.display = 'none';
            constraintToolsDropdown.style.display = 'none';
            modifyToolsDropdown.style.display = modifyToolsDropdown.style.display === 'block' ? 'none' : 'block';
        });
        
        deleteButton.addEventListener('click', () => {
            if (selectedElement) {
                deleteElement(selectedElement);
            }
        });

        zoomFitButton.addEventListener('click', () => {
            const allShapes = [...polygons, ...rectangles, ...circles, ...arcs, ...ellipses, ...splines];
            if (allShapes.length === 0) return;

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            allShapes.forEach(shape => {
                if (shape.type === 'polygon') {
                    shape.lines.forEach(line => {
                         if(line.type === 'arc') {
                            minX = Math.min(minX, line.cx - line.radius);
                            minY = Math.min(minY, line.cy - line.radius);
                            maxX = Math.max(maxX, line.cx + line.radius);
                            maxY = Math.max(maxY, line.cy + line.radius);
                        } else {
                            minX = Math.min(minX, line.x1, line.x2);
                            minY = Math.min(minY, line.y1, line.y2);
                            maxX = Math.max(maxX, line.x1, line.x2);
                            maxY = Math.max(maxY, line.y1, line.y2);
                        }
                    });
                } else if (shape.type === 'rectangle') {
                    minX = Math.min(minX, shape.x);
                    minY = Math.min(minY, shape.y);
                    maxX = Math.max(maxX, shape.x + shape.width);
                    maxY = Math.max(maxY, shape.y + shape.height);
                } else if (shape.type === 'circle') {
                    minX = Math.min(minX, shape.x - shape.radius);
                    minY = Math.min(minY, shape.y - shape.radius);
                    maxX = Math.max(maxX, shape.x + shape.radius);
                    maxY = Math.max(maxY, shape.y + shape.radius);
                } else if (shape.type === 'arc') {
                    minX = Math.min(minX, shape.cx - shape.radius);
                    minY = Math.min(minY, shape.cy - shape.radius);
                    maxX = Math.max(maxX, shape.cx + shape.radius);
                    maxY = Math.max(maxY, shape.cy + shape.radius);
                } else if (shape.type === 'ellipse') {
                    minX = Math.min(minX, shape.x - shape.radiusX);
                    minY = Math.min(minY, shape.y - shape.radiusY);
                    maxX = Math.max(maxX, shape.x + shape.radiusX);
                    maxY = Math.max(maxY, shape.y + shape.radiusY);
                } else if (shape.type === 'spline') {
                    shape.points.forEach(p => {
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                }
            });
            
            if (!isFinite(minX)) return; // No valid geometry to zoom to

            const bboxWidth = maxX - minX;
            const bboxHeight = maxY - minY;
            const bboxCenterX = minX + bboxWidth / 2;
            const bboxCenterY = minY + bboxHeight / 2;

            const padding = 50; // pixels
            const scaleX = (canvas.width - padding * 2) / (bboxWidth || canvas.width);
            const scaleY = (canvas.height - padding * 2) / (bboxHeight || canvas.height);
            scale = Math.min(scaleX, scaleY) * 0.9;
            if (scale === 0 || !isFinite(scale)) scale = 1.0;
            
            offsetX = (canvas.width / (2 * scale)) - bboxCenterX;
            offsetY = (canvas.height / (2 * scale)) - bboxCenterY;

            draw();
        });
        
        // ===============================================
        // Inspector Panel Logic
        // ===============================================
        
        let isDraggingInspector = false;
        let inspectorOffsetX, inspectorOffsetY;

        shapeInspectorPanel.addEventListener('mousedown', (e) => {
            // Prevent dragging when clicking on form elements, their labels, or buttons
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'LABEL') {
                return;
            }
            isDraggingInspector = true;
            inspectorOffsetX = e.clientX - shapeInspectorPanel.offsetLeft;
            inspectorOffsetY = e.clientY - shapeInspectorPanel.offsetTop;
            // Prevent text selection while dragging
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDraggingInspector) {
                shapeInspectorPanel.style.left = `${e.clientX - inspectorOffsetX}px`;
                shapeInspectorPanel.style.top = `${e.clientY - inspectorOffsetY}px`;
            }
            if (isDraggingDimensionModal) {
                editDimensionModal.style.left = `${e.clientX - dimensionModalOffsetX}px`;
                editDimensionModal.style.top = `${e.clientY - dimensionModalOffsetY}px`;
            }
        });
        
        document.addEventListener('mouseup', () => {
            isDraggingInspector = false;
            isDraggingDimensionModal = false;
        });
        
        inspectorOkButton.addEventListener('click', () => {
            if (editingShape) {
                editingShape.color = lineColorInput.value;
                editingShape.lineWidth = parseInt(lineWidthInput.value, 10);
                editingShape.lineType = lineTypeSelect.value;
                
                shapeInspectorPanel.style.display = 'none';
                editingShape = null;
                saveState();
                draw();
            }
        });
        
        inspectorCancelButton.addEventListener('click', () => {
            shapeInspectorPanel.style.display = 'none';
            editingShape = null;
        });

        editDimensionModal.addEventListener('mousedown', (e) => {
            // Prevent dragging when clicking on form elements
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'LABEL') {
                return;
            }
            isDraggingDimensionModal = true;
            dimensionModalOffsetX = e.clientX - editDimensionModal.offsetLeft;
            dimensionModalOffsetY = e.clientY - editDimensionModal.offsetTop;
            e.preventDefault();
        });
        
        // ===============================================
        // Parametric Update Logic
        // ===============================================

        function rotatePoint(point, center, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const dx = point.x - center.x;
            const dy = point.y - center.y;
            const nx = center.x + dx * cos - dy * sin;
            const ny = center.y + dx * sin + dy * cos;
            return { x: nx, y: ny };
        }

        function moveGeometricPoint(elementInfo, dx, dy) {
            const shape = findShapeById(elementInfo.shapeId, elementInfo.shapeType);
            if (!shape) return;

            if (elementInfo.type === 'point') {
                if (shape.type === 'polygon') {
                    if (elementInfo.pointType === 'start') {
                        shape.lines[elementInfo.lineIndex].x1 += dx;
                        shape.lines[elementInfo.lineIndex].y1 += dy;
                        // Update connected line
                        if (elementInfo.lineIndex > 0) {
                            shape.lines[elementInfo.lineIndex - 1].x2 += dx;
                            shape.lines[elementInfo.lineIndex - 1].y2 += dy;
                        } else if (shape.isClosed) {
                            shape.lines[shape.lines.length - 1].x2 += dx;
                            shape.lines[shape.lines.length - 1].y2 += dy;
                        }
                    } else { // 'end'
                        shape.lines[elementInfo.lineIndex].x2 += dx;
                        shape.lines[elementInfo.lineIndex].y2 += dy;
                        // Update connected line
                        if (elementInfo.lineIndex < shape.lines.length - 1) {
                            shape.lines[elementInfo.lineIndex + 1].x1 += dx;
                            shape.lines[elementInfo.lineIndex + 1].y1 += dy;
                        } else if (shape.isClosed) {
                            shape.lines[0].x1 += dx;
                            shape.lines[0].y1 += dy;
                        }
                    }
                } else if (shape.type === 'rectangle') {
                    const r = shape;
                    switch (elementInfo.corner) {
                        case 'topLeft': r.x += dx; r.y += dy; r.width -= dx; r.height -= dy; break;
                        case 'topRight': r.width += dx; r.y += dy; r.height -= dy; break;
                        case 'bottomLeft': r.x += dx; r.width -= dx; r.height += dy; break;
                        case 'bottomRight': r.width += dx; r.height += dy; break;
                    }
                }
            } else if (elementInfo.type === 'circle_center') {
                shape.x += dx;
                shape.y += dy;
            } else if (elementInfo.shapeType === 'arc') { // Handle moving arc points/center
                if (elementInfo.type === 'arc_center') {
                    // Translate the entire arc by moving its center and defining points
                    shape.cx += dx; shape.cy += dy;
                    shape.p1.x += dx; shape.p1.y += dy;
                    shape.p2.x += dx; shape.p2.y += dy;
                    shape.p3.x += dx; shape.p3.y += dy;
                    // Angles remain the same relative to the new center
                    shape.startAngle = Math.atan2(shape.p1.y - shape.cy, shape.p1.x - shape.cx);
                    shape.endAngle = Math.atan2(shape.p2.y - shape.cy, shape.p2.x - shape.cx);
                } else if (elementInfo.type === 'point') {
                    // Update one of the defining points and recalculate the arc
                    let newP1 = { ...shape.p1 }, newP2 = { ...shape.p2 }, newP3 = { ...shape.p3 };

                    if (elementInfo.pointType === 'start') {
                        newP1 = { x: shape.p1.x + dx, y: shape.p1.y + dy };
                    } else { // 'end'
                        newP2 = { x: shape.p2.x + dx, y: shape.p2.y + dy };
                    }
                    
                    const newArcParams = calculateArcFromThreePoints(newP1, newP2, newP3);
                    if (newArcParams) {
                        shape.p1 = newP1;
                        shape.p2 = newP2;
                        shape.cx = newArcParams.x;
                        shape.cy = newArcParams.y;
                        shape.radius = newArcParams.radius;
                        shape.startAngle = newArcParams.startAngle;
                        shape.endAngle = newArcParams.endAngle;
                        shape.anticlockwise = newArcParams.anticlockwise;
                    }
                }
            }
        }

        function updateShapeFromDimension(dim, newValue) {
            const el1 = dim.element1;
            const shape1 = findShapeById(el1.shapeId, el1.shapeType);
            if (!shape1) return;

            switch (dim.dimensionType) {
                case 'diameter':
                    if (shape1.type === 'circle') {
                        shape1.radius = newValue / 2; // newValue is in pixels
                    }
                    break;
                case 'radius':
                    if (shape1.type === 'arc') {
                        shape1.radius = newValue; // newValue is in pixels
                    }
                    break;
                case 'ellipse_radiusX':
                    if (shape1.type === 'ellipse') {
                        shape1.radiusX = newValue; // newValue is in pixels
                    }
                    break;
                case 'ellipse_radiusY':
                    if (shape1.type === 'ellipse') {
                        shape1.radiusY = newValue; // newValue is in pixels
                    }
                    break;

                case 'line': // This handles single edges, like rectangle sides
                    if (shape1.type === 'rectangle') {
                        if (el1.side === 'top' || el1.side === 'bottom') {
                            shape1.width = newValue; // newValue is in pixels
                        } else if (el1.side === 'left' || el1.side === 'right') {
                            shape1.height = newValue; // newValue is in pixels
                        }
                    } else if (shape1.type === 'polygon') {
                        // Anchor p1, move p2
                        const line = shape1.lines[el1.lineIndex];
                        const p1 = { x: line.x1, y: line.y1 };
                        const p2 = { x: line.x2, y: line.y2 };
                        const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                        const newP2 = {
                            x: p1.x + Math.cos(angle) * newValue, // newValue is in pixels
                            y: p1.y + Math.sin(angle) * newValue,
                        };
                        
                        const dx = newP2.x - p2.x;
                        const dy = newP2.y - p2.y;

                        // Move p2 and any connected lines
                        moveGeometricPointByLinePoint({shapeId: shape1.id, shapeType: 'polygon', lineIndex: el1.lineIndex}, 'end', dx, dy);
                    }
                    break;

                case 'horizontal':
                case 'vertical':
                case 'aligned':
                    const el2 = dim.element2;
                    if (!el2) return;
                    
                    // Simple approach: Anchor element1's point, move element2's point
                    const p1 = getPointFromElementInfo(el1);
                    const p2_original = getPointFromElementInfo(el2);
                    if (!p1 || !p2_original) return;

                    let dx = 0, dy = 0;

                    if (dim.dimensionType === 'horizontal') {
                        dx = (p1.x + newValue * Math.sign(p2_original.x - p1.x)) - p2_original.x;
                    } else if (dim.dimensionType === 'vertical') {
                        dy = (p1.y + newValue * Math.sign(p2_original.y - p1.y)) - p2_original.y;
                    } else { // aligned
                        const angle = Math.atan2(p2_original.y - p1.y, p2_original.x - p1.x);
                        const newP2 = {
                            x: p1.x + Math.cos(angle) * newValue,
                            y: p1.y + Math.sin(angle) * newValue
                        };
                        dx = newP2.x - p2_original.x;
                        dy = newP2.y - p2_original.y;
                    }
                    
                    // Apply this dx, dy to the point from element2
                    moveGeometricPoint(el2, dx, dy);
                    break;
                    
                case 'angle': {
                    let newAngleDeg = newValue; // newValue is from user input in degrees.

                    // Update the reflex flag based on user input. The user is defining the angle they see.
                    dim.isReflex = newAngleDeg > 180;

                    // The angle of rotation should always be based on the smallest angle between the lines.
                    const innerAngleRad = (dim.isReflex ? 360 - newAngleDeg : newAngleDeg) * (Math.PI / 180);

                    const line1_info = getLineFromElementInfo(dim.element1);
                    const line2_info = getLineFromElementInfo(dim.element2);
                    if (!line1_info || !line2_info) break;

                    const intersection = findLineIntersection(line1_info, line2_info, false);
                    if (!intersection) break;

                    const p1_start = {x: line1_info.x1, y: line1_info.y1};
                    const p1_end = {x: line1_info.x2, y: line1_info.y2};
                    const p2_start = {x: line2_info.x1, y: line2_info.y1};
                    const p2_end = {x: line2_info.x2, y: line2_info.y2};

                    const v1_vec = getDistance(intersection, p1_start) > getDistance(intersection, p1_end) ? {x: p1_start.x - intersection.x, y: p1_start.y - intersection.y} : {x: p1_end.x - intersection.x, y: p1_end.y - intersection.y};
                    const v2_vec_current = getDistance(intersection, p2_start) > getDistance(intersection, p2_end) ? {x: p2_start.x - intersection.x, y: p2_start.y - intersection.y} : {x: p2_end.x - intersection.x, y: p2_end.y - intersection.y};
                    
                    const angle1 = Math.atan2(v1_vec.y, v1_vec.x);
                    const angle2_current = Math.atan2(v2_vec_current.y, v2_vec_current.x);
                    
                    const cross_v1_v2 = v1_vec.x * v2_vec_current.y - v1_vec.y * v2_vec_current.x;
                    
                    const targetAngle2 = angle1 + innerAngleRad * Math.sign(cross_v1_v2);
                    
                    const angleDiff = targetAngle2 - angle2_current;

                    const p2_to_rotate = getDistance(intersection, p2_start) > getDistance(intersection, p2_end) ? p2_start : p2_end;
                    
                    const rotatedPoint = rotatePoint(p2_to_rotate, intersection, angleDiff);
                    const dx = rotatedPoint.x - p2_to_rotate.x;
                    const dy = rotatedPoint.y - p2_to_rotate.y;
                    
                    const pointTypeToMove = getDistance(intersection, p2_start) > getDistance(intersection, p2_end) ? 'start' : 'end';
                    moveGeometricPointByLinePoint(dim.element2, pointTypeToMove, dx, dy);
                    
                    break;
                }
            }
        }

        function safeEval(expression) {
            try {
                // Only allow numbers, basic operators, parentheses, and dots.
                if (/^[\d\s()+\-*/.]+$/.test(expression)) {
                    // Use Function constructor for safer evaluation
                    return new Function('return ' + expression)();
                }
                return null;
            } catch (e) {
                console.error("Invalid expression:", e);
                return null;
            }
        }

        okEditButton.addEventListener('click', () => {
            if (editingDimension) {
                const expression = dimensionValueInput.value;
                const calculatedValue = safeEval(expression);

                if (calculatedValue !== null && !isNaN(calculatedValue)) {
                    let finalValue;
                    if (editingDimension.dimensionType === 'angle') {
                        finalValue = calculatedValue; // For angles, the value is already in degrees
                    } else {
                        finalValue = mmToPixels(calculatedValue); // Convert mm to pixels
                    }
                    
                    updateShapeFromDimension(editingDimension, finalValue);
                    
                    applyConstraints();
                    saveState();
                    draw();

                    editDimensionModal.style.display = 'none';
                    editingDimension = null;
                } else {
                    // Optional: show an error to the user that the expression is invalid
                    dimensionValueInput.style.borderColor = 'red';
                }
            }
        });

        cancelEditButton.addEventListener('click', () => {
            editDimensionModal.style.display = 'none';
            editingDimension = null;
            dimensionValueInput.style.borderColor = ''; // Reset border color
        });
        
        snapButton.addEventListener('click', () => {
            isSnapEnabled = !isSnapEnabled;
            snapButton.classList.toggle('active-tool');
        });

        gridButton.addEventListener('click', () => {
            isGridVisible = !isGridVisible;
            gridButton.classList.toggle('active-tool');
            draw();
        });

        // ===============================================
        // NEW: Intersection and Trim Helper Functions
        // ===============================================
        
        /**
         * Checks if a point lies on a given line segment.
         */
        function isPointOnLineSegment(p, a, b, tolerance = 0.1) {
            const distAP = getDistance(a, p);
            const distPB = getDistance(p, b);
            const distAB = getDistance(a, b);
            return Math.abs(distAP + distPB - distAB) < tolerance;
        }

        /**
         * Checks if a point lies on the path of an arc.
         */
        function isPointOnArc(p, arc, tolerance = 0.1) {
            if (Math.abs(getDistance(p, {x: arc.cx, y: arc.cy}) - arc.radius) > tolerance) {
                return false; // Not on the circle's path
            }
            let angle = normalizeAngle(Math.atan2(p.y - arc.cy, p.x - arc.cx));
            let start = normalizeAngle(arc.startAngle);
            let end = normalizeAngle(arc.endAngle);

            if (arc.clockwise) { // If clockwise, start angle is greater than end angle
                if (start < end) start += 2 * Math.PI; // Handle wrap around
                return angle <= start && angle >= end;
            } else { // Counter-clockwise
                if (start > end) end += 2 * Math.PI; // Handle wrap around
                return angle >= start && angle <= end;
            }
        }

        /**
         * Finds intersection points between a line and a circle.
         */
        function findLineCircleIntersections(line, circle) {
            const {x1, y1, x2, y2} = line;
            const {x: cx, y: cy, radius: r} = circle;
            
            const dx = x2 - x1;
            const dy = y2 - y1;
            const A = dx * dx + dy * dy;
            const B = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
            const C = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
            
            const det = B * B - 4 * A * C;
            if (A <= 0.0000001 || det < 0) return [];

            const points = [];
            if (det === 0) {
                const t = -B / (2 * A);
                points.push({ x: x1 + t * dx, y: y1 + t * dy });
            } else {
                const t1 = (-B + Math.sqrt(det)) / (2 * A);
                const t2 = (-B - Math.sqrt(det)) / (2 * A);
                points.push({ x: x1 + t1 * dx, y: y1 + t1 * dy });
                points.push({ x: x1 + t2 * dx, y: y1 + t2 * dy });
            }
            return points;
        }

        /**
         * Finds intersection points between two circles.
         */
        function findCircleCircleIntersections(c1, c2) {
            const {x: x1, y: y1, radius: r1} = c1;
            const {x: x2, y: y2, radius: r2} = c2;

            const d = getDistance({x:x1, y:y1}, {x:x2, y:y2});
            if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) return [];

            const a = (r1*r1 - r2*r2 + d*d) / (2*d);
            const h = Math.sqrt(r1*r1 - a*a);

            const x_mid = x1 + a * (x2 - x1) / d;
            const y_mid = y1 + a * (y2 - y1) / d;

            const points = [];
            points.push({
                x: x_mid + h * (y2 - y1) / d,
                y: y_mid - h * (x2 - x1) / d
            });

            if (h > 0) { // Avoid duplicate point if circles are tangent
                points.push({
                    x: x_mid - h * (y2 - y1) / d,
                    y: y_mid + h * (x2 - x1) / d
                });
            }
            return points;
        }

        // ===============================================
        // Modifier Logic (REFACTORED)
        // ===============================================
        function resetModifier() {
            modifierStep = 0;
            firstElementForModifier = null;
            secondElementForModifier = null;
        }

        function performSmartTrim(elementToTrim, clickX, clickY) {
            const shapeToTrim = findShapeById(elementToTrim.shapeId, elementToTrim.shapeType);
            if (!shapeToTrim) return;

            // 1. Collect all other shapes as potential trimming boundaries
            const boundaries = [];
            [...polygons, ...rectangles, ...circles, ...arcs, ...ellipses, ...splines].forEach(s => {
                if (s.id === shapeToTrim.id && s.type === shapeToTrim.type) return;
                boundaries.push(s);
            });

            // 2. Find all valid intersection points on the shape to be trimmed
            let allIntersections = [];
            boundaries.forEach(boundary => {
                let intersections = [];
                // --- Calculate intersections based on shape types ---
                if ((shapeToTrim.type === 'polygon' || shapeToTrim.type === 'rectangle') && (boundary.type === 'polygon' || boundary.type === 'rectangle')) {
                    // Line vs Line (already handled in existing logic)
                } else if ((shapeToTrim.type === 'polygon' || shapeToTrim.type === 'rectangle') && (boundary.type === 'circle' || boundary.type === 'arc')) {
                    const line = shapeToTrim.lines[elementToTrim.lineIndex];
                    intersections = findLineCircleIntersections(line, boundary);
                }
                //... more combinations needed for full functionality

                // --- Filter intersections to be on both segments ---
                allIntersections.push(...intersections.filter(p => {
                    // check if point p lies on both shapeToTrim segment AND boundary segment
                    return true; // Simplified for now
                }));

            });

            // --- Fallback to old line-only trim if no smarter intersections found ---
            if (shapeToTrim.type === 'polygon' || shapeToTrim.type === 'rectangle') {
                const originalLine = getLineFromElementInfo(elementToTrim);
                if (!originalLine) return;
                
                let lineToTrim = {...originalLine};
                let intersections = [];

                const allOtherLines = [];
                polygons.forEach(p => p.lines.forEach(l => { 
                    if (p.id !== shapeToTrim.id || l.x1 !== lineToTrim.x1 || l.y1 !== lineToTrim.y1) allOtherLines.push(l) 
                }));
                rectangles.forEach(r => {
                    if (r.id !== shapeToTrim.id) {
                        allOtherLines.push({ x1: r.x, y1: r.y, x2: r.x + r.width, y2: r.y });
                        allOtherLines.push({ x1: r.x + r.width, y1: r.y, x2: r.x + r.width, y2: r.y + r.height });
                        allOtherLines.push({ x1: r.x + r.width, y1: r.y + r.height, x2: r.x, y2: r.y + r.height });
                        allOtherLines.push({ x1: r.x, y1: r.y + r.height, x2: r.x, y2: r.y });
                    }
                });

                allOtherLines.forEach(otherLine => {
                    const intersection = findLineIntersection(lineToTrim, otherLine, true);
                    if (intersection) intersections.push(intersection);
                });
                
                if (intersections.length === 0) return;

                let closestIntersection = intersections[0];
                let minDistance = getDistance({x: clickX, y: clickY}, closestIntersection);
                for (let i = 1; i < intersections.length; i++) {
                    const dist = getDistance({x: clickX, y: clickY}, intersections[i]);
                    if (dist < minDistance) {
                        minDistance = dist;
                        closestIntersection = intersections[i];
                    }
                }
                
                if (getDistance({x: clickX, y: clickY}, {x: lineToTrim.x1, y: lineToTrim.y1}) < getDistance({x: clickX, y: clickY}, {x: lineToTrim.x2, y: lineToTrim.y2})) {
                    lineToTrim.x1 = closestIntersection.x;
                    lineToTrim.y1 = closestIntersection.y;
                } else {
                    lineToTrim.x2 = closestIntersection.x;
                    lineToTrim.y2 = closestIntersection.y;
                }
                
                if(shapeToTrim.type === 'polygon') {
                    shapeToTrim.lines[elementToTrim.lineIndex] = lineToTrim;
                }
                 else if (shapeToTrim.type === 'rectangle') {
                    // Convert rectangle to polygon to allow one side to be trimmed
                    const rect = shapeToTrim;
                    const newPolygonLines = [
                        { x1: rect.x, y1: rect.y, x2: rect.x + rect.width, y2: rect.y },
                        { x1: rect.x + rect.width, y1: rect.y, x2: rect.x + rect.width, y2: rect.y + rect.height },
                        { x1: rect.x + rect.width, y1: r.y + rect.height, x2: rect.x, y2: rect.y + rect.height },
                        { x1: rect.x, y1: rect.y + rect.height, x2: rect.x, y2: rect.y }
                    ];
                    const sideMap = { top: 0, right: 1, bottom: 2, left: 3 };
                    const lineIndex = sideMap[elementToTrim.side];
                    newPolygonLines[lineIndex] = lineToTrim;

                    polygons.push({
                        id: polygonIdCounter++, isClosed: false, type: 'polygon', lines: newPolygonLines,
                        color: rect.color, lineWidth: rect.lineWidth, lineType: rect.lineType
                    });
                    rectangles = rectangles.filter(r => r.id !== rect.id);
                }

                saveState();
                draw();
            }
        }

        function performPolygonOffset(polygon, offset) {
            if (polygon.lines.some(line => line.type === 'arc')) {
                console.warn("Offset for polygons with fillets/arcs is not yet supported.");
                return; 
            }

            if (polygon.isClosed) {
                let area = 0;
                for (let i = 0; i < polygon.lines.length; i++) {
                    const p1 = {x: polygon.lines[i].x1, y: polygon.lines[i].y1};
                    const p2 = {x: polygon.lines[i].x2, y: polygon.lines[i].y2};
                    area += (p1.x * p2.y - p2.x * p1.y);
                }
                
                const effectiveOffset = (area > 0) ? -offset : offset;

                const offsetLines = [];
                for(const line of polygon.lines) {
                    const dx = line.x2 - line.x1;
                    const dy = line.y2 - line.y1;
                    const length = Math.sqrt(dx*dx + dy*dy);
                    if(length === 0) continue;

                    const normalX = -dy / length;
                    const normalY = dx / length;
                    
                    offsetLines.push({
                        x1: line.x1 + normalX * effectiveOffset,
                        y1: line.y1 + normalY * effectiveOffset,
                        x2: line.x2 + normalX * effectiveOffset,
                        y2: line.y2 + normalY * effectiveOffset
                    });
                }
                
                const newVertices = [];
                for (let i = 0; i < offsetLines.length; i++) {
                    const currentLine = offsetLines[i];
                    const nextLine = offsetLines[(i + 1) % offsetLines.length];
                    const intersection = findLineIntersection(currentLine, nextLine, false);
                    
                    if (intersection) {
                        newVertices.push(intersection);
                    } else {
                        console.warn("Offset failed due to parallel segments. This can happen on concave shapes.");
                        return;
                    }
                }

                if (newVertices.length > 2) {
                    const newLines = [];
                    for (let i = 0; i < newVertices.length; i++) {
                        const p1 = newVertices[i];
                        const p2 = newVertices[(i + 1) % newVertices.length];
                        newLines.push({ x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y });
                    }

                    polygons.push({
                        id: polygonIdCounter++,
                        isClosed: true,
                        type: 'polygon',
                        lines: newLines,
                        color: polygon.color, lineWidth: polygon.lineWidth, lineType: polygon.lineType
                    });
                    saveState();
                }
            } else { // Handle open polylines
                const newLines = [];
                for(const line of polygon.lines) {
                    const dx = line.x2 - line.x1;
                    const dy = line.y2 - line.y1;
                    const length = Math.sqrt(dx*dx + dy*dy);
                    if(length === 0) continue;

                    const normalX = -dy / length;
                    const normalY = dx / length;
                    
                    newLines.push({
                        x1: line.x1 + normalX * offset,
                        y1: line.y1 + normalY * offset,
                        x2: line.x2 + normalX * offset,
                        y2: line.y2 + normalY * offset
                    });
                }

                if (newLines.length > 0) {
                    polygons.push({
                        id: polygonIdCounter++,
                        isClosed: false,
                        type: 'polygon',
                        lines: newLines,
                        color: polygon.color, 
                        lineWidth: polygon.lineWidth, 
                        lineType: polygon.lineType
                    });
                    saveState();
                }
            }
        }

        function performRectangleOffset(rect, offset) {
            rectangles.push({
                id: rectangleIdCounter++,
                type: 'rectangle',
                x: rect.x - offset,
                y: rect.y - offset,
                width: rect.width + 2 * offset,
                height: rect.height + 2 * offset,
                color: rect.color,
                lineWidth: rect.lineWidth,
                lineType: rect.lineType
            });
            saveState();
        }

        function performCircleOffset(circle, offset) {
            const newRadius = circle.radius + offset;
            if (newRadius > 0) {
                 circles.push({
                    id: circleIdCounter++,
                    type: 'circle',
                    x: circle.x,
                    y: circle.y,
                    radius: newRadius,
                    color: circle.color,
                    lineWidth: circle.lineWidth,
                    lineType: circle.lineType
                });
                saveState();
            }
        }
        
        function performChamfer(line1Info, line2Info, distance, angle) {
             const polygon = findShapeById(line1Info.shapeId, 'polygon');
             if(!polygon) return;
             
             let l1_idx = line1Info.lineIndex;
             let l2_idx = line2Info.lineIndex;
             let line1 = polygon.lines[l1_idx];
             let line2 = polygon.lines[l2_idx];
             
             // --- Robustly find common vertex and other points ---
             let commonVertex, p1_other, p2_other;
             let l1_endpointToUpdate = '', l2_endpointToUpdate = '';

             if (getDistance({x: line1.x1, y: line1.y1}, {x: line2.x1, y: line2.y1}) < 1) {
                 commonVertex = {x: line1.x1, y: line1.y1}; p1_other = {x: line1.x2, y: line1.y2}; p2_other = {x: line2.x2, y: line2.y2};
                 l1_endpointToUpdate = 'start'; l2_endpointToUpdate = 'start';
             } else if (getDistance({x: line1.x1, y: line1.y1}, {x: line2.x2, y: line2.y2}) < 1) {
                 commonVertex = {x: line1.x1, y: line1.y1}; p1_other = {x: line1.x2, y: line1.y2}; p2_other = {x: line2.x1, y: line2.y1};
                 l1_endpointToUpdate = 'start'; l2_endpointToUpdate = 'end';
             } else if (getDistance({x: line1.x2, y: line1.y2}, {x: line2.x1, y: line2.y1}) < 1) {
                 commonVertex = {x: line1.x2, y: line1.y2}; p1_other = {x: line1.x1, y: line1.y1}; p2_other = {x: line2.x2, y: line2.y2};
                 l1_endpointToUpdate = 'end'; l2_endpointToUpdate = 'start';
             } else if (getDistance({x: line1.x2, y: line1.y2}, {x: line2.x2, y: line2.y2}) < 1) {
                 commonVertex = {x: line1.x2, y: line1.y2}; p1_other = {x: line1.x1, y: line1.y1}; p2_other = {x: line2.x1, y: line2.y1};
                 l1_endpointToUpdate = 'end'; l2_endpointToUpdate = 'end';
             } else {
                 console.warn("Selected lines do not share a common vertex.");
                 return;
             }
             
             const v1x = p1_other.x - commonVertex.x;
             const v1y = p1_other.y - commonVertex.y;
             const len1 = getDistance(p1_other, commonVertex);
             if (distance > len1) distance = len1;
             
             const chamferP1 = {x: commonVertex.x + (v1x/len1) * distance, y: commonVertex.y + (v1y/len1) * distance};
             
             const angleRad = angle * Math.PI / 180;
             const line1Angle = Math.atan2(v1y, v1x);
             const crossProduct = v1x * (p2_other.y - commonVertex.y) - v1y * (p2_other.x - commonVertex.x);
             const chamferLineAngle = line1Angle + (crossProduct < 0 ? angleRad : -angleRad);

             const chamferLineRay = {
                 x1: chamferP1.x, y1: chamferP1.y,
                 x2: chamferP1.x + Math.cos(chamferLineAngle),
                 y2: chamferP1.y + Math.sin(chamferLineAngle)
             };
             
             const line2AsInfinite = {x1: commonVertex.x, y1: commonVertex.y, x2: p2_other.x, y2: p2_other.y};
             const chamferP2 = findLineIntersection(chamferLineRay, line2AsInfinite, false);

             if (!chamferP2 || getDistance(commonVertex, chamferP2) > getDistance(commonVertex, p2_other)) {
                console.warn("Chamfer angle results in an invalid intersection.");
                return;
             }
             
             // Update the correct endpoints
             if (l1_endpointToUpdate === 'start') { line1.x1 = chamferP1.x; line1.y1 = chamferP1.y; } 
             else { line1.x2 = chamferP1.x; line1.y2 = chamferP1.y; }

             if (l2_endpointToUpdate === 'start') { line2.x1 = chamferP2.x; line2.y1 = chamferP2.y; }
             else { line2.x2 = chamferP2.x; line2.y2 = chamferP2.y; }

             
             const chamferLine = {x1: chamferP1.x, y1: chamferP1.y, x2: chamferP2.x, y2: chamferP2.y};
             // Insert the new line logically between the two modified lines
             const insertIndex = Math.max(l1_idx, l2_idx);
             polygon.lines.splice(insertIndex, 0, chamferLine);
             
             saveState();
        }
        
        function performFillet(line1Info, line2Info, radius) {
            const polygon = findShapeById(line1Info.shapeId, 'polygon');
             if(!polygon) return;
             
             let l1_idx = line1Info.lineIndex;
             let l2_idx = line2Info.lineIndex;
             let line1 = polygon.lines[l1_idx];
             let line2 = polygon.lines[l2_idx];
             
             // --- Robustly find common vertex and other points ---
             let commonVertex, p1_other, p2_other;
             let l1_endpointToUpdate = '', l2_endpointToUpdate = '';

             if (getDistance({x: line1.x1, y: line1.y1}, {x: line2.x1, y: line2.y1}) < 1) {
                 commonVertex = {x: line1.x1, y: line1.y1}; p1_other = {x: line1.x2, y: line1.y2}; p2_other = {x: line2.x2, y: line2.y2};
                 l1_endpointToUpdate = 'start'; l2_endpointToUpdate = 'start';
             } else if (getDistance({x: line1.x1, y: line1.y1}, {x: line2.x2, y: line2.y2}) < 1) {
                 commonVertex = {x: line1.x1, y: line1.y1}; p1_other = {x: line1.x2, y: line1.y2}; p2_other = {x: line2.x1, y: line2.y1};
                 l1_endpointToUpdate = 'start'; l2_endpointToUpdate = 'end';
             } else if (getDistance({x: line1.x2, y: line1.y2}, {x: line2.x1, y: line2.y1}) < 1) {
                 commonVertex = {x: line1.x2, y: line1.y2}; p1_other = {x: line1.x1, y: line1.y1}; p2_other = {x: line2.x2, y: line2.y2};
                 l1_endpointToUpdate = 'end'; l2_endpointToUpdate = 'start';
             } else if (getDistance({x: line1.x2, y: line1.y2}, {x: line2.x2, y: line2.y2}) < 1) {
                 commonVertex = {x: line1.x2, y: line1.y2}; p1_other = {x: line1.x1, y: line1.y1}; p2_other = {x: line2.x1, y: line2.y1};
                 l1_endpointToUpdate = 'end'; l2_endpointToUpdate = 'end';
             } else {
                 console.warn("Selected lines do not share a common vertex.");
                 return;
             }
             
             const v1x = p1_other.x - commonVertex.x, v1y = p1_other.y - commonVertex.y;
             const v2x = p2_other.x - commonVertex.x, v2y = p2_other.y - commonVertex.y;
             
             const angle1 = Math.atan2(v1y, v1x);
             const angle2 = Math.atan2(v2y, v2x);
             let angleBetween = angle2 - angle1;
             
             if (angleBetween > Math.PI) angleBetween -= 2 * Math.PI;
             if (angleBetween < -Math.PI) angleBetween += 2 * Math.PI;

             const tangentDist = Math.abs(radius / Math.tan(angleBetween / 2));
             
             const len1 = getDistance(commonVertex, p1_other);
             if (tangentDist > len1) { console.warn("Fillet radius too large for segment 1"); return; }
             const tangentP1 = {x: commonVertex.x + (v1x/len1) * tangentDist, y: commonVertex.y + (v1y/len1) * tangentDist};

             const len2 = getDistance(commonVertex, p2_other);
             if (tangentDist > len2) { console.warn("Fillet radius too large for segment 2"); return; }
             const tangentP2 = {x: commonVertex.x + (v2x/len2) * tangentDist, y: commonVertex.y + (v2y/len2) * tangentDist};

             const bisectorAngle = angle1 + angleBetween / 2;
             const centerDist = Math.sqrt(tangentDist*tangentDist + radius*radius);
             const arcCenter = {
                x: commonVertex.x + Math.cos(bisectorAngle) * centerDist,
                y: commonVertex.y + Math.sin(bisectorAngle) * centerDist
             };
             
             const startAngle = Math.atan2(tangentP1.y - arcCenter.y, tangentP1.x - arcCenter.x);
             const endAngle = Math.atan2(tangentP2.y - arcCenter.y, tangentP2.x - arcCenter.x);
             
             // Update the correct endpoints
             if (l1_endpointToUpdate === 'start') { line1.x1 = tangentP1.x; line1.y1 = tangentP1.y; } 
             else { line1.x2 = tangentP1.x; line1.y2 = tangentP1.y; }

             if (l2_endpointToUpdate === 'start') { line2.x1 = tangentP2.x; line2.y1 = tangentP2.y; }
             else { line2.x2 = tangentP2.x; line2.y2 = tangentP2.y; }

             const filletArc = { type: 'arc', cx: arcCenter.x, cy: arcCenter.y, radius, startAngle, endAngle, clockwise: angleBetween < 0 };
             // Insert the new line logically between the two modified lines
             const insertIndex = Math.max(l1_idx, l2_idx);
             polygon.lines.splice(insertIndex, 0, filletArc);
             
             saveState();
        }

        okModifierButton.addEventListener('click', () => {
            const value = parseFloat(modifierValueInput.value);
            if(isNaN(value)) {
                modifierValueInput.style.borderColor = 'red';
                return;
            }
            modifierValueInput.style.borderColor = '';
            
            const valueInPixels = mmToPixels(value);

            if(currentTool === 'offset' && firstElementForModifier) {
                 const isInverse = inverseOffsetCheckbox.checked;
                 const effectiveOffset = isInverse ? -valueInPixels : valueInPixels;
                 switch(firstElementForModifier.type) {
                    case 'polygon': performPolygonOffset(firstElementForModifier, effectiveOffset); break;
                    case 'rectangle': performRectangleOffset(firstElementForModifier, effectiveOffset); break;
                    case 'circle': performCircleOffset(firstElementForModifier, effectiveOffset); break;
                }
            } else if (currentTool === 'fillet' && firstElementForModifier && secondElementForModifier) {
                performFillet(firstElementForModifier, secondElementForModifier, valueInPixels);
            } else if (currentTool === 'chamfer' && firstElementForModifier && secondElementForModifier) {
                const angle = parseFloat(chamferAngleInput.value);
                if (isNaN(angle)) {
                    chamferAngleInput.style.borderColor = 'red';
                    return;
                }
                chamferAngleInput.style.borderColor = '';
                performChamfer(firstElementForModifier, secondElementForModifier, valueInPixels, angle);
            }

            modifierModal.style.display = 'none';
            resetModifier();
            draw();
        });

        cancelModifierButton.addEventListener('click', () => {
            modifierModal.style.display = 'none';
            resetModifier();
        });

        // ===============================================
        // Constraint Logic
        // ===============================================

        function resetConstraintCreation() {
            constraintCreationStep = 0;
            firstElementForConstraint = null;
        }

        function getPointFromElementInfo(elementInfo) {
            if (!elementInfo) return null;
            const shape = findShapeById(elementInfo.shapeId, elementInfo.shapeType);
            if (!shape) return null;

            switch (elementInfo.type) {
                case 'point':
                    if (elementInfo.shapeType === 'polygon') {
                        if (elementInfo.pointType === 'start') return { x: shape.lines[elementInfo.lineIndex].x1, y: shape.lines[elementInfo.lineIndex].y1 };
                        else return { x: shape.lines[elementInfo.lineIndex].x2, y: shape.lines[elementInfo.lineIndex].y2 };
                    }
                    if (elementInfo.shapeType === 'rectangle') {
                        if (elementInfo.corner === 'topLeft') return {x: shape.x, y: shape.y};
                        if (elementInfo.corner === 'topRight') return {x: shape.x + shape.width, y: shape.y};
                        if (elementInfo.corner === 'bottomLeft') return {x: shape.x, y: shape.y + shape.height};
                        if (elementInfo.corner === 'bottomRight') return {x: shape.x + shape.width, y: shape.y + shape.height};
                    }
                    if (elementInfo.shapeType === 'arc') {
                        if (elementInfo.pointType === 'start') {
                            return { x: shape.cx + shape.radius * Math.cos(shape.startAngle), y: shape.cy + shape.radius * Math.sin(shape.startAngle) };
                        } else { // 'end'
                            return { x: shape.cx + shape.radius * Math.cos(shape.endAngle), y: shape.cy + shape.radius * Math.sin(shape.endAngle) };
                        }
                    }
                    break;
                case 'circle_center':
                    return { x: shape.x, y: shape.y };
                case 'arc_center':
                    return { x: shape.cx, y: shape.cy };
            }
            return null;
        }

        function getClosestPointOnLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const l2 = dx * dx + dy * dy;
            if (l2 === 0) return { x: x1, y: y1 };
            let t = ((px - x1) * dx + (py - y1) * dy) / l2;
            t = Math.max(0, Math.min(1, t));
            return { x: x1 + t * dx, y: y1 + t * dy };
        }

        function applyConstraints() {
            // Apply multiple times to solve dependencies
            for (let i = 0; i < 5; i++) { 
                constraints.forEach(constraint => {
                    if (constraint.type === 'coincident') {
                        const element1 = constraint.element1;
                        const element2 = constraint.element2;
                        const shape1 = findShapeById(element1.shapeId, element1.shapeType);
                        if (!shape1) return;

                        let targetPoint = null;
                        const shape2 = findShapeById(element2.shapeId, element2.shapeType);
                        if (!shape2) return;

                        // Determine the target coordinate
                        if (element2.type === 'point' || element2.type === 'circle_center') {
                            targetPoint = getPointFromElementInfo(element2);
                        } else if (element2.type === 'edge') {
                            const pointToMove = getPointFromElementInfo(element1);
                            if (!pointToMove) return;
                            if (element2.shapeType === 'polygon') {
                                const line = shape2.lines[element2.lineIndex];
                                const proj = getClosestPointOnLineSegment(pointToMove.x, pointToMove.y, line.x1, line.y1, line.x2, line.y2);
                                targetPoint = { x: proj.x, y: proj.y };
                            } else if (element2.shapeType === 'rectangle') {
                                const r = shape2;
                                const sides = [
                                    { name: 'top', x1: r.x, y1: r.y, x2: r.x + r.width, y2: r.y },
                                    { name: 'right', x1: r.x + r.width, y1: r.y, x2: r.x + r.width, y2: r.y + r.height },
                                    { name: 'bottom', x1: r.x + r.width, y1: r.y + r.height, x2: r.x, y2: r.y + r.height },
                                    { name: 'left', x1: r.x, y1: r.y + r.height, x2: r.x, y2: r.y }
                                ];
                                const side = sides.find(s => s.name === element2.side);
                                if (side) {
                                    const proj = getClosestPointOnLineSegment(pointToMove.x, pointToMove.y, side.x1, side.y1, side.x2, side.y2);
                                    targetPoint = { x: proj.x, y: proj.y };
                                }
                            }
                        } else if (element2.type === 'circle_contour') {
                            const pointToMove = getPointFromElementInfo(element1);
                            if (!pointToMove) return;
                            const angle = Math.atan2(pointToMove.y - shape2.y, pointToMove.x - shape2.x);
                            targetPoint = {
                                x: shape2.x + Math.cos(angle) * shape2.radius,
                                y: shape2.y + Math.sin(angle) * shape2.radius
                            };
                        }

                        if (!targetPoint) return;

                        // Update the position of element1
                        const pointToMove = getPointFromElementInfo(element1);
                        if (!pointToMove) return;
                        const dx = targetPoint.x - pointToMove.x;
                        const dy = targetPoint.y - pointToMove.y;
                        moveGeometricPoint(element1, dx, dy);

                    } else if (constraint.type === 'tangent') {
                        const element1 = constraint.element1;
                        const element2 = constraint.element2;
                        const shape1 = findShapeById(element1.shapeId, element1.shapeType);
                        const shape2 = findShapeById(element2.shapeId, element2.shapeType);
                        if (!shape1 || !shape2) return;

                        if (element1.shapeType === 'circle' && element2.shapeType === 'circle') {
                            const dist = getDistance(shape1, shape2);
                            const targetDist = shape1.radius + shape2.radius;
                            if (Math.abs(dist - targetDist) > 0.1) {
                                const error = targetDist - dist;
                                const angle = Math.atan2(shape2.y - shape1.y, shape2.x - shape1.x);
                                shape2.x += Math.cos(angle) * error;
                                shape2.y += Math.sin(angle) * error;
                            }
                        } else {
                            const circle = element1.shapeType === 'circle' ? shape1 : shape2;
                            const lineShape = element1.shapeType !== 'circle' ? shape1 : shape2;
                            const lineInfo = element1.shapeType !== 'circle' ? element1 : element2;
                            
                            let line;
                            if (lineShape.type === 'polygon') {
                                line = lineShape.lines[lineInfo.lineIndex];
                            } else if (lineShape.type === 'rectangle') {
                                const r = lineShape;
                                const sides = [
                                    { name: 'top', x1: r.x, y1: r.y, x2: r.x + r.width, y2: r.y },
                                    { name: 'right', x1: r.x + r.width, y1: r.y, x2: r.x + r.width, y2: r.y + r.height },
                                    { name: 'bottom', x1: r.x + r.width, y1: r.y + r.height, x2: r.x, y2: r.y + r.height },
                                    { name: 'left', x1: r.x, y1: r.y + r.height, x2: r.x, y2: r.y }
                                ];
                                line = sides.find(s => s.name === lineInfo.side);
                            }
                            if (!line) return;

                            const dist = getDistanceFromLineSegment(circle.x, circle.y, line.x1, line.y1, line.x2, line.y2);
                            const error = dist - circle.radius;
                            if (Math.abs(error) > 0.1) {
                                const closestPoint = getClosestPointOnLineSegment(circle.x, circle.y, line.x1, line.y1, line.x2, line.y2);
                                const vec = { x: circle.x - closestPoint.x, y: circle.y - closestPoint.y };
                                const len = getDistance({x:0, y:0}, vec);
                                if (len < 0.01) return; // Avoid division by zero if circle center is on the line
                                const moveVec = { x: (vec.x / len) * error, y: (vec.y / len) * error };
                                
                                // Move the circle instead of the line shape for more predictable behavior.
                                circle.x -= moveVec.x;
                                circle.y -= moveVec.y;
                            }
                        }
                    } else if (constraint.type === 'horizontal') {
                        const line = getLineFromElementInfo(constraint.element1);
                        if (line) {
                            const dy = line.y1 - line.y2;
                            if (Math.abs(dy) > 0.01) {
                                moveGeometricPointByLinePoint(constraint.element1, 'end', 0, dy);
                            }
                        }
                    } else if (constraint.type === 'vertical') {
                        const line = getLineFromElementInfo(constraint.element1);
                        if (line) {
                            const dx = line.x1 - line.x2;
                            if (Math.abs(dx) > 0.01) {
                                moveGeometricPointByLinePoint(constraint.element1, 'end', dx, 0);
                            }
                        }
                    } else if (constraint.type === 'alignHorizontal') {
                        const p1 = getPointFromElementInfo(constraint.element1);
                        const p2 = getPointFromElementInfo(constraint.element2);
                        if (p1 && p2) {
                            const dy = p1.y - p2.y;
                            if (Math.abs(dy) > 0.01) {
                                moveGeometricPoint(constraint.element2, 0, dy);
                            }
                        }
                    } else if (constraint.type === 'alignVertical') {
                        const p1 = getPointFromElementInfo(constraint.element1);
                        const p2 = getPointFromElementInfo(constraint.element2);
                        if (p1 && p2) {
                            const dx = p1.x - p2.x;
                            if (Math.abs(dx) > 0.01) {
                                moveGeometricPoint(constraint.element2, dx, 0);
                            }
                        }
                    } else if (constraint.type === 'parallel') {
                        const line1 = getLineFromElementInfo(constraint.element1);
                        const line2_info = constraint.element2;
                        let line2 = getLineFromElementInfo(line2_info);
                        if (!line1 || !line2) return;

                        const angle1 = Math.atan2(line1.y2 - line1.y1, line1.x2 - line1.x1);
                        const angle2 = Math.atan2(line2.y2 - line2.y1, line2.x2 - line2.x1);
                        
                        const normAngle1 = (angle1 % Math.PI + Math.PI) % Math.PI;
                        const normAngle2 = (angle2 % Math.PI + Math.PI) % Math.PI;

                        if (Math.abs(normAngle1 - normAngle2) > 0.001) {
                            const angleDiff = angle1 - angle2;
                            const p2_start = { x: line2.x1, y: line2.y1 };
                            const p2_end = { x: line2.x2, y: line2.y2 };
                            const rotated_p2_end = rotatePoint(p2_end, p2_start, angleDiff);
                            const dx = rotated_p2_end.x - p2_end.x;
                            const dy = rotated_p2_end.y - p2_end.y;
                            moveGeometricPointByLinePoint(line2_info, 'end', dx, dy);
                        }
                    } else if (constraint.type === 'perpendicular') {
                        const line1 = getLineFromElementInfo(constraint.element1);
                        const line2_info = constraint.element2;
                        const line2 = getLineFromElementInfo(line2_info);
                        if (!line1 || !line2) return;

                        const angle1 = Math.atan2(line1.y2 - line1.y1, line1.x2 - line1.x1);
                        const angle2 = Math.atan2(line2.y2 - line2.y1, line2.x2 - line2.x1);
                        
                        const targetAngle = angle1 + Math.PI / 2;
                        
                        let angleDiff = targetAngle - angle2;
                        let angleDiffAlt = targetAngle - (angle2 + Math.PI);
                        if(Math.abs(angleDiffAlt) < Math.abs(angleDiff)) angleDiff = angleDiffAlt;
                        angleDiffAlt = targetAngle - (angle2 - Math.PI);
                        if(Math.abs(angleDiffAlt) < Math.abs(angleDiff)) angleDiff = angleDiffAlt;

                        if (Math.abs(angleDiff) > 0.001) {
                            const p2_start = { x: line2.x1, y: line2.y1 };
                            const p2_end = { x: line2.x2, y: line2.y2 };
                            const rotated_p2_end = rotatePoint(p2_end, p2_start, angleDiff);
                            const dx = rotated_p2_end.x - p2_end.x;
                            const dy = rotated_p2_end.y - p2_end.y;
                            moveGeometricPointByLinePoint(line2_info, 'end', dx, dy);
                        }
                    } else if (constraint.type === 'collinear') {
                        const line1 = getLineFromElementInfo(constraint.element1);
                        const line2_info = constraint.element2;
                        const line2_shape = findShapeById(line2_info.shapeId, line2_info.shapeType);
                        let line2 = getLineFromElementInfo(line2_info);
                        if (!line1 || !line2 || !line2_shape) return;

                        // Step 1: Make parallel
                        const angle1 = Math.atan2(line1.y2 - line1.y1, line1.x2 - line1.x1);
                        const angle2 = Math.atan2(line2.y2 - line2.y1, line2.x2 - line2.x1);
                        
                        const normAngle1 = (angle1 % Math.PI + Math.PI) % Math.PI;
                        const normAngle2 = (angle2 % Math.PI + Math.PI) % Math.PI;

                        if (Math.abs(normAngle1 - normAngle2) > 0.001) {
                            const angleDiff = angle1 - angle2;
                            const p2_start = { x: line2.x1, y: line2.y1 };
                            const p2_end = { x: line2.x2, y: line2.y2 };
                            const rotated_p2_end = rotatePoint(p2_end, p2_start, angleDiff);
                            const dx_rot = rotated_p2_end.x - p2_end.x;
                            const dy_rot = rotated_p2_end.y - p2_end.y;
                            moveGeometricPointByLinePoint(line2_info, 'end', dx_rot, dy_rot);
                            line2 = getLineFromElementInfo(line2_info); 
                        }

                        // Step 2: Move line2 onto the infinite line of line1
                        const p1_start = { x: line1.x1, y: line1.y1 };
                        const p2_start = { x: line2.x1, y: line2.y1 };
                        
                        const dx_line1 = line1.x2 - line1.x1;
                        const dy_line1 = line1.y2 - line1.y1;
                        if (dx_line1 === 0 && dy_line1 === 0) return;
                        
                        const t = ((p2_start.x - p1_start.x) * dx_line1 + (p2_start.y - p1_start.y) * dy_line1) / (dx_line1 * dx_line1 + dy_line1 * dy_line1);
                        const closestPoint = { x: p1_start.x + t * dx_line1, y: p1_start.y + t * dy_line1 };
                        
                        const dx_trans = closestPoint.x - p2_start.x;
                        const dy_trans = closestPoint.y - p2_start.y;
                        
                        if (Math.abs(dx_trans) > 0.01 || Math.abs(dy_trans) > 0.01) {
                            if (line2_shape.type === 'polygon') {
                                line2_shape.lines.forEach(line => {
                                    line.x1 += dx_trans; line.y1 += dy_trans;
                                    line.x2 += dx_trans; line.y2 += dy_trans;
                                });
                            } else if (line2_shape.type === 'rectangle') {
                                line2_shape.x += dx_trans;
                                line2_shape.y += dy_trans;
                            }
                        }
                    }
                });

                // Apply fix constraints last, as they override other movements
                constraints.forEach(constraint => {
                    if (constraint.type === 'fix') {
                        const currentPoint = getPointFromElementInfo(constraint.element1);
                        if (currentPoint) {
                            const dx = constraint.x - currentPoint.x;
                            const dy = constraint.y - currentPoint.y;
                            if (Math.abs(dx) > 0.01 || Math.abs(dy) > 0.01) {
                                moveGeometricPoint(constraint.element1, dx, dy);
                            }
                        }
                    }
                });
            }
        }
    </script>
</body>
</html>

-->


